<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[wfsoverign'notes]]></title>
  <subtitle><![CDATA[A love world boy]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wfsovereign.github.io/"/>
  <updated>2015-10-25T14:59:33.129Z</updated>
  <id>http://wfsovereign.github.io/</id>
  
  <author>
    <name><![CDATA[wfsovereign]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[New Begin]]></title>
    <link href="http://wfsovereign.github.io/2015/10/25/new-begin/"/>
    <id>http://wfsovereign.github.io/2015/10/25/new-begin/</id>
    <published>2015-10-25T12:17:37.000Z</published>
    <updated>2015-10-25T14:59:33.129Z</updated>
    <content type="html"><![CDATA[<p>时隔半年之久，终于，我又拾起了blog。</p>
<hr>
<p>自去年十月份开始正式走上程序员这条道路起，学习也一年有余。由一次意外得到的消息加入Thoughtworks的培训项目– Thoughtworks Academy，在这里，自学两月javascript、html、css等前端基础，然后在仝老师、玉姐、硕哥等的辅导下，接触互联网技术的最前沿思想，学习Thoughtworks的软件制作流程、TDD开发模式、团队合作，收获了很多…这段日子让我能够独立的去面对新技术而游刃有余，时常想念这段美好的日子，好想你们啊～</p>
<p>接着便是大四去公司完成实习任务，但在这个公司用的却是java，做的工作也是后端sql维护等，同事相对来说没有那种学习的朝气，与我当初进入这个领域所接受的思想完全不符，不开心，而作为程序员来说，不开心意味着就不会长久。因此，在七月底的时候，舍弃了很多，克服了很多，还是坚持了自己的选择，离开公司，去远方，做自己想做的工作。我觉得，男人就是该拼一拼，哈哈</p>
<p>杭州，初来乍到，请多指教。一个人来到杭州，诸多不便，但是在公司的工作却让我动力十足，做着自己喜欢的事情，几乎感觉不到疲惫。每晚八九点下班回家还能再写写自己的项目，那股兴奋劲自己都害怕，虽然时常顶着个黑眼圈，哈哈哈</p>
<p>blog很久没开更了，这段时间做了很多东西，也没来得及总结，就趁着这篇New Begin，慢慢的沉淀吧～</p>
<p>Let’s go！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>时隔半年之久，终于，我又拾起了blog。</p>
<hr>
<p>自去年十月份开始正式走上程序员这条道路起，学习也一年有余。由一次意外得到的消息加入Thoughtworks的培训项目– Thoughtworks Academy，在这里，自学两月javascript、html]]>
    </summary>
    
      <category term="成长" scheme="http://wfsovereign.github.io/tags/%E6%88%90%E9%95%BF/"/>
    
      <category term="独立" scheme="http://wfsovereign.github.io/tags/%E7%8B%AC%E7%AB%8B/"/>
    
      <category term="经历" scheme="http://wfsovereign.github.io/categories/%E7%BB%8F%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式之代理模式]]></title>
    <link href="http://wfsovereign.github.io/2015/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://wfsovereign.github.io/2015/04/22/设计模式之代理模式/</id>
    <published>2015-04-22T08:39:00.000Z</published>
    <updated>2015-10-26T14:20:40.272Z</updated>
    <content type="html"><![CDATA[<p>该篇讲主要讲述我学习代理模式的心得记录。</p>
<h2 id="代理模式基本属性">代理模式基本属性</h2><h3 id="1、定义">1、定义</h3><p>一个类可以作为其它东西的接口。代理者可以作任何东西的接口：网络连接、存储器中的大对象、文件或其它昂贵或无法复制的资源。而代理又分为静态代理和动态代理，其中动态代理具有更强的灵活性，不用在我们设计实现的时候就指定某一个代理类来代理哪一个被代理对象，而是把这种实现推迟到程序运行时。</p>
<h3 id="2、应用场景">2、应用场景</h3><p>功能需要被授予不同的权限时，如，注册与未注册的用户。</p>
<h3 id="3、优点">3、优点</h3><p>一个复杂对象可以由多个代理来引用，这样便节省了系统资源。</p>
<h2 id="实例讲解">实例讲解</h2><h3 id="1、静态代理">1、静态代理</h3><p>首先定义一个抽象类AbstractObject并在其内部定义一个抽象的方法，作为代理和被代理类的父类，</p>
<pre><code> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractObject</span> {
  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span>(<span class="params"></span>)</span>;
}
</code></pre><p>，然后创造一个继承了此父类的被代理类，</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">RealObject</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractObject</span> {</span>
  <span class="annotation">@Override</span>
  public void operation(){
      <span class="type">System</span>.out.println(<span class="string">"some operation"</span>);
 }
 }
</code></pre><p>再创造一个代理类，</p>
<pre><code> public <span class="class"><span class="keyword">class</span> <span class="title">ProxyObject</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractObject</span> {</span>
   <span class="type">RealObject</span> realObject = <span class="keyword">new</span> <span class="type">RealObject</span>();
 <span class="annotation">@Override</span>
     public void operation() {
       <span class="type">System</span>.out.println(<span class="string">"before"</span>);
       realObject.operation();
       <span class="type">System</span>.out.println(<span class="string">"after"</span>);
   }
}
</code></pre><p>在代理类中创建了一个父类，并且在重写的方法中调用了被代理类的同名方法。这便实现了一个简单的静态代理。</p>
<p>回顾一下思路，它实现一个共有的抽象类，代理与被代理均继承于这个类，在代理类中构造被代理类作为一个私有成员，并且在重写的方法中调用被代理类中重写的方法，并且可在该方法中添加自己的行为，最后客户端调用代理类中他们的共有接口，实现代理操作。</p>
<p>感觉和装饰者模式有些类似，均实现了相同的接口，通过调用底层的类来实现他们的功能。不过装饰者模式是将被装饰者作为参数传入，而静态代理是作为自己的私有成员变量。</p>
<h3 id="2、动态代理">2、动态代理</h3><p>我们采用定义接口的方式来实现，首先定义一个接口AbstractSubject，</p>
<pre><code> <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">AbstractSubject</span> {
  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">request</span>(<span class="params"></span>)</span>;
}
</code></pre><p>接着就是我们被代理的对象，</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">AbstractSubject</span> </span>{
 <span class="annotation">@Override</span>
 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span>
 </span>{
     System.out.println(<span class="string">"real subject's request()........"</span>);
 }
}
</code></pre><p>在被代理类中我们重写了接口中定义的方法，接着再实现最重要的代理类，</p>
<pre><code>public class <span class="type">DynamicProxy</span> implements 
<span class="type">InvocationHandler</span> {
     <span class="type">Object</span> beProxy = null;
 public <span class="type">DynamicProxy</span>(<span class="type">Object</span> beProxy){
     this.beProxy = beProxy;
    }
     @<span class="type">Override</span>
   public <span class="type">Object</span> invoke(<span class="type">Object</span> o, <span class="type">Method</span> <span class="keyword">method</span>, <span class="type">Object</span>[] objects) throws <span class="type">Throwable</span> {
       <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"before ----------"</span>+<span class="keyword">method</span>);
      <span class="type">Object</span> <span class="literal">result</span> = <span class="keyword">method</span>.invoke(this.beProxy,objects);
      <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"after ----------"</span>+<span class="keyword">method</span>);
        <span class="keyword">return</span> <span class="literal">result</span>;
  }
}
</code></pre><p>在这个代理类中，我们有一个需要传入被代理类对象的构造方法，而它实现的接口是系统自带的InvocationHandler，并且重写了invoke（）方法。最后，我们来看一下，我们是怎么使用这个代理的，</p>
<pre><code>  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DynamicProxyClient</span> {
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>{
        AbstractSubject realSubject = <span class="keyword">new</span> RealSubject();
        ClassLoader loader = realSubject.getClass().getClassLoader();
      Class&lt;?&gt;[] interfaces = realSubject.getClass().getInterfaces();

     InvocationHandler dynamicProxyHandler = <span class="keyword">new</span> DynamicProxy(realSubject);

AbstractSubject proxy = (AbstractSubject) Proxy.newProxyInstance(loader, interfaces, dynamicProxyHandler);
        proxy.request();
    }
 }
</code></pre><p>　　　　<br>使用java原生的Proxy类与InvocationHandler接口，通过自己所写的DynamicProxy实现InvocationHandler接口，在程序运行时，newProxyInstance（）方法通过接收类加载器ClassLoader，动态代理类所实现的接口interface以及实现了InvocationHandler接口的动态类实例DynamicProxy，创建一个动态代理proxy。</p>
<p>其中，在DynamicProxy类中重写的invoke（）方法，则是动态代理所必须执行的，因为Proxy.newProxyInstance（）方法返回的是一个继承于Proxy的子类对象，通过调用该对象的代理方法，会执行父对象中InvocationHandler成员的invoke（）方法，因此，最终执行了我们在DynamicProxy中重写的invoke（）方法。关于最后proxy调用request（）方法为什么就能执行到被代理类的方法，这里我再做一次说明。因为proxy是属于Proxy类的，因为他的类是com.sun.proxy.$Proxy0，是继承了Proxy类的，而在$Proxy0中重写了request（）方法，并且调用了父类中h的invoke方法，而在父类Proxy中，h是这样定义的，</p>
<pre><code><span class="keyword">protected</span> InvocationHandler h;
</code></pre><p>也就是说调用的是InvocationHandler.invoke（）方法，而DynamicProxy又实现了InvocationHandler接口的invoke（）方法，因此，最后调用的便是DynamicProxy中的invoke（）方法。这也就是java内置的动态代理实现机制。</p>
<h2 id="总结">总结</h2><p>学习了该模式之后，有了些感悟。设计模式，究其本质，就是一些方式方法，并且是适合面向对象这种语言的方法，我们通过这些方法能够顺利的达到我们所需要的目的，并且能够让我们的代码结构变得更清晰，更具逻辑。这便是设计模式的目的吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>该篇讲主要讲述我学习代理模式的心得记录。</p>
<h2 id="代理模式基本属性">代理模式基本属性</h2><h3 id="1、定义">1、定义</h3><p>一个类可以作为其它东西的接口。代理者可以作任何东西的接口：网络连接、存储器中的大对象、文件或其它昂贵或无法复制]]>
    </summary>
    
      <category term="java" scheme="http://wfsovereign.github.io/tags/java/"/>
    
      <category term="代理模式" scheme="http://wfsovereign.github.io/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://wfsovereign.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://wfsovereign.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://wfsovereign.github.io/2015/04/06/hello-world/"/>
    <id>http://wfsovereign.github.io/2015/04/06/hello-world/</id>
    <published>2015-04-06T12:17:37.000Z</published>
    <updated>2015-10-25T13:59:11.013Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <link href="http://wfsovereign.github.io/2015/03/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://wfsovereign.github.io/2015/03/28/设计模式之单例模式/</id>
    <published>2015-03-28T08:40:00.000Z</published>
    <updated>2015-10-26T14:10:37.100Z</updated>
    <content type="html"><![CDATA[<p>各个模式均有自己的出现的理由以及应用场景，相较于普通代码有一定的优势的时候的，设计模式便也应运而生了。今天所要记录的单例模式，它的优势在哪呢？</p>
<h2 id="单例模式简历">单例模式简历</h2><h3 id="1、出生原因">1、出生原因</h3><p>当我们在一个管理者管辖范围不明确，各个部门间的领导互相插手彼此部门间的事物，员工一会被这个boss分配任务，一会被那个boss分配任务的公司里，作为一个普通员工，您怎么想？对于一个管理层这样混乱与模糊的公司，您怎么看？在一个项目中也一样，我们的某些类，一会被这个实例化，一会被那个实例化，而这个类的功能却是很单一的管理着同样一个领域，这个时候，你会不会想着做点什么来结束这个混乱的现象呢？重构、优化一下吧，特定的领域管理交由一个固定的对象来管理，那么，这个时候，单例模式就出现了。</p>
<h3 id="2、定义">2、定义</h3><p>单例对象的类必须保证只有一个实例存在，通过阻止外部实例化和修改，来控制所创建的对象的数量。</p>
<h3 id="3、适用情况">3、适用情况</h3><p>整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</p>
<h3 id="4、实现思路">4、实现思路</h3><p>一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</p>
<h3 id="5、亮点">5、亮点</h3><p>整个系统中只有这么一个实例对象，方便各处的运用，也方便管理该对象所要管理的东西。</p>
<h2 id="实例讲解">实例讲解</h2><p>接下来，我们通过三个不同层次的单例模式实例，来较为深入的理解在java代码中如何实现及其原理。</p>
<p>首先，在我们的level1包下面创建Singleton类，</p>
<pre><code>public class Singleton {
 <span class="keyword"> private</span><span class="keyword"> static</span> Singleton<span class="instruction"> instance </span> = null;
  <span class="keyword"> public</span><span class="keyword"> static</span> Singleton<span class="function"> getInstance(</span><span class="function">)</span>{
      <span class="function"> if(</span>instance == null<span class="function">)</span>{
         <span class="instruction"> instance </span>=<span class="instruction"> new </span>Singleton(<span class="function">)</span>;
      }
      <span class="instruction"> return </span>instance;
   }
   <span class="keyword"> private</span><span class="function"> Singleton(</span><span class="function">)</span> {}
   <span class="keyword"> public</span> void<span class="function"> doSomething(</span><span class="function">)</span>{
     <span class="function"> System.out.println(</span><span class="string">"'how are you'"</span><span class="function">)</span>;
  }
}
</code></pre><p>将Singleton的构造函数私有化，阻止外部实例化，再通过调用一个共有的接口getInstance（）方法，首先if（instance == null）判断其是否创建，再返回instance对象。这一切看起来都还挺不错的，一环接一环的保证了咱们Singleton类只返回一个实例化对象instance。可是真的是这样吗？让我们的大脑跑起A、B双线程来，假如当A准备创建instance的时候B正好进行if（）判断语句，这个时候instance == null 是要返回true的，那么，这种情况肯定就会创建两个instance对象了，所有，这个实现方法在多线程里，是不安全的单例模式，或者说多线程情况下，这种实现不合理。</p>
<p>那么，开动我们的大脑，想想办法来控制他的实例化判断。于是，会写出如下代码：</p>
<pre><code><span class="keyword"> public</span> class Singleton {
  <span class="keyword"> private</span><span class="keyword"> static</span> Singleton<span class="instruction"> instance </span>= null;
 <span class="keyword"> public</span><span class="keyword"> static</span> Singleton<span class="function"> getInstance(</span><span class="function">)</span> {
   <span class="instruction"> if </span>(instance == null<span class="function">)</span> {
      synchronized<span class="function"> (</span>Singleton.class<span class="function">)</span> {                   <span class="instruction"> if </span>(instance == null<span class="function">)</span> {
       <span class="instruction"> instance </span>=<span class="instruction"> new </span>Singleton(<span class="function">)</span>;
                 }
        }
      }
     <span class="instruction"> return </span>instance;
  }
   <span class="keyword"> private</span><span class="function"> Singleton(</span><span class="function">)</span> {
  }
 <span class="keyword"> public</span> void<span class="function"> doSomething(</span><span class="function">)</span> {
     <span class="function"> System.out.println(</span><span class="string">"'how are you'"</span><span class="function">)</span>;
  }
}
</code></pre><p>我们通过double-checked-locking的方法来阻止其多线程运行。当getInstance（）方法被调用的时候，首先进行null值检测，若是false直接返回instance，否则，运行同步锁，（synchronized，它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码），然后再进行null值检测，返回instance。这样，我们的程序就没有多线程情况下被多次创建的可能。感觉，程序写到这里，已经是很酷了，其实我也觉得，哈哈。不过，当我们了解创建一个变量的步骤时，可能就会有疑问了。</p>
<p>创建一个变量，有以下几个步骤：申请一块内存，调用构造方法进行初始化，分配一个指针指向这块内存。而这些都是JVM来执行，但是JVM仅仅是一个标准，没有规定编译器优化的内容，导致其可以自由进行优化，在不改变原来语义的情况下，通过调整语句顺序，来让程序运行的更快。那么，就有可能会出现这种情况：当A线程开始创建Singleton实例时，B线程调用getInstance（）方法检测null时，假如此时A已经将instance指向了那块内存，但还没有赋值，那么B线程检测null时会直接返回instance，但是instance的构造并没有完成，程序便出错了。</p>
<p>这可让我们很是懊恼，怎么感觉处处碰壁的样子，难道JAVA就不能安全的实现单例模式吗？结果肯定是有的，平下心来，我们来看看接下来的实现：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> {
   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>) </span>{
   }
     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SingletonInstance</span> {
       <span class="keyword">private</span> <span class="keyword">static</span> final Singleton instance = <span class="keyword">new</span> Singleton();
   }
     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>(<span class="params"></span>) </span>{
      <span class="keyword">return</span> SingletonInstance.instance;
  }   
  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>{
      System.<span class="keyword">out</span>.println(<span class="string">"'how are you'"</span>);
  }
}
</code></pre><p>使用java静态内部类，JVM能够保证当一个类被加载时，这个加载过程是互斥的。调用getInstance（）方法时，首先加载SingletonInstance类，这个类有一个static实例，所以需要调用Singleton的构造方法，最后getInstance将这个instance返回给使用者。</p>
<h2 id="总结">总结</h2><p>通过学习单例模式之后，感觉学习一门语言，仅仅浅显的学习是不够的，有时候，你仅仅知道怎么用，你可能永远都写不出好的程序，这不是危言耸听。据我所知，优秀的程序员，几乎都学习过编译原理，当然，信息来源于知乎，因为自己平时知乎浏览的要多一些。所以，编译原理，已经被我提上今后的日程表了。</p>
<p>设计模式这一块，可能得暂时停下来了，因为有了新的任务，不过剩下的一篇代理模式我会抽空更新的，这是我的承诺@杜珊</p>
<p><strong>加油吧，大家～！！</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>各个模式均有自己的出现的理由以及应用场景，相较于普通代码有一定的优势的时候的，设计模式便也应运而生了。今天所要记录的单例模式，它的优势在哪呢？</p>
<h2 id="单例模式简历">单例模式简历</h2><h3 id="1、出生原因">1、出生原因</h3><p>当我们在]]>
    </summary>
    
      <category term="java" scheme="http://wfsovereign.github.io/tags/java/"/>
    
      <category term="单例模式" scheme="http://wfsovereign.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://wfsovereign.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://wfsovereign.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式之工厂模式]]></title>
    <link href="http://wfsovereign.github.io/2015/03/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://wfsovereign.github.io/2015/03/23/设计模式之工厂模式/</id>
    <published>2015-03-23T07:23:00.000Z</published>
    <updated>2015-10-26T14:10:37.104Z</updated>
    <content type="html"><![CDATA[<p>最近在学习设计模式的路上越走越远…</p>
<p>今天主要记录记录一下学习的工厂模式。</p>
<h2 id="工厂模式简历">工厂模式简历</h2><h3 id="1、由来">1、由来　　　　</h3><p>当我们创建一个对象，而这个对象的创建过程序纷繁复杂，可能导致大量的重复代码的时候，工厂模式出现了。工厂方法模式通过定义一个单独的创建对象的方法来解决这些问题。由子类实现这个方法来创建具体类型的对象。也就是说，在我们的实际运用中，工厂就是一个用来创建其他对象的对象。</p>
<h3 id="2、实质">2、实质</h3><p>定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。</p>
<h3 id="3、现状介绍">3、现状介绍</h3><p>工厂模式目前有三个分支，简单工厂模式，工厂方法模式和抽象工厂方法模式，其中，我主要学习的是抽象工厂方法模式，因为该方法是工厂模式中最高层的方法。简单工厂模式，工厂类根据传参不同得到不同的产品。工厂方法模式能够创建这个系列中的各种产品，比如，iphone的各种配件。而抽象工厂模式作为更高级的模式，它可以创建整个苹果公司各个产品流水线，比如，他可以创建生产iphone配件的工厂，可以创建生产ipad配件的工厂等等。那么，抽象工厂模式与工厂方法模式的最大区别就在于，工厂方法模式针对的是一个产品等级结构，它能够创建这一个等级结构中的产品族；而抽象工厂模式则需要面对多个产品等级结构，也就是说，抽象工厂方法模式可以工厂方法模式中的工厂。</p>
<h3 id="4、三分支的关系">4、三分支的关系</h3><p>简单工厂模式通常伴随着对象的具体类型与工厂具体类型的一一对应，客户端代码根据需要选择合适的具体类型工厂使用。当这个选择包含复杂的逻辑时，就可以创建一个单一的工厂类，用以包含这种选择逻辑，根据参数的不同选择实现不同的具体对象。这个工厂类不需要由每个具体产品实现一个自己的具体的工厂类，所以可以将工厂方法设置为静态方法，这就有了工厂方法模式。而抽象工厂方法模式便是封装着这样一组有着共同主题的工厂方法模式中的工厂。</p>
<p>　　</p>
<h2 id="三分支的应用场景">三分支的应用场景</h2><h3 id="1、简单工厂模式">1、简单工厂模式</h3><p>当我们的主程序中需要自己手动初始化一个对象，但是我们并不想关注具体的初始化过程，这个时候简单工厂模式就是您的选择。</p>
<h3 id="2、工厂方法模式">2、工厂方法模式</h3><p>当你觉得传入参数的这种简单的工厂模式让你程序容易出错，并且程序中的if-else让你的程序看起来有些臃肿，这个时候工厂方法模式就是您的选择。</p>
<h3 id="3、抽象工厂方法模式">3、抽象工厂方法模式</h3><p>当你工厂类需要修改时，而在工厂方法模式中需要修改原有的工厂类，这就违背了设计原则中的OCP（开放闭合原则），这个时候，抽象工厂方法模式就是您的选择。 </p>
<h2 id="实际应用">实际应用</h2><p>说不如做，看的再多不自己亲手做一做来的有效率，这便是我学习工厂模式之后的心得。</p>
<p>首先，模拟场景。创建宝马车，X6和5系的，那么首先的有一个抽象的汽车工厂，CarFactory，由它来生成X6和5系的工厂，一个汽车工厂生产出来的汽车至少得有个壳，发动机，变速箱啥的，所有就有了方法。创建CarFactory如下：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">CarFactory</span> {
  <span class="function"><span class="keyword">public</span> CarFrame <span class="title">createCarFrame</span>(<span class="params"></span>)</span>;
  <span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span>(<span class="params"></span>)</span>;
  <span class="function"><span class="keyword">public</span> Gearbox <span class="title">createGearbox</span>(<span class="params"></span>)</span>;
 }
</code></pre><p>一个汽车的基本配件都出来了，那么所有的配件都应该有各自的接口，我们再分别创建Engine，Gearbox和CarFrame，Engine如下（Gearbox、CarFrame类似）：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Engine</span> {
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createEngine</span>(<span class="params"></span>)</span>;
 }
</code></pre><p>然后我们的X6和5系的都应该有这些个接口吧，我们在分别创建他们各自的Engine，Gearbox和CarFrame，X6的Engine：</p>
<pre><code> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BwmXSixEngine</span> <span class="keyword">implements</span> <span class="title">Engine</span> </span>{
     <span class="keyword">private</span> String emissions;
     <span class="function"><span class="keyword">public</span> <span class="title">BwmXSixEngine</span><span class="params">(String emissions)</span></span>{
         <span class="keyword">this</span>.emissions = emissions;
   }
<span class="annotation">@Override</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createEngine</span><span class="params">()</span> </span>{
     System.out.println(<span class="string">"this BWM XDrive engine,and emissions is "</span>+ <span class="keyword">this</span>.emissions);
     }
}
</code></pre><p>5系的Engine：</p>
<pre><code> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BwmFiveSeriesEngine</span> <span class="keyword">implements</span> <span class="title">Engine</span> </span>{
<span class="keyword">private</span> <span class="keyword">final</span> String emissions;
<span class="function"><span class="keyword">public</span> <span class="title">BwmFiveSeriesEngine</span><span class="params">(String emissions)</span></span>{
    <span class="keyword">this</span>.emissions = emissions;
    }
 <span class="annotation">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createEngine</span><span class="params">()</span> </span>{
       System.out.println(<span class="string">"this is BWMFiveSeriesEngine it's emissions of "</span>+<span class="keyword">this</span>.emissions);
}
}
</code></pre><p>现在，X6和5系就只差装箱，我们就来创建他们的工厂吧，5系：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BwmFiveSeriesFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span></span>{
<span class="annotation">@Override</span>
 <span class="function"><span class="keyword">public</span> CarFrame <span class="title">createCarFrame</span><span class="params">()</span> </span>{
  <span class="keyword">return</span> <span class="keyword">new</span> BwmFiveSeriesCarFrame(<span class="string">"中大型车"</span>, <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">5047</span>,<span class="number">1860</span>,<span class="number">1491</span>},<span class="string">"4门5座三厢车"</span>);
}
<span class="annotation">@Override</span>
 <span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span> </span>{
      <span class="keyword">return</span> <span class="keyword">new</span> BwmFiveSeriesEngine(<span class="string">"2.0T"</span>);
  }
<span class="annotation">@Override</span>
<span class="function"><span class="keyword">public</span> Gearbox <span class="title">createGearbox</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="keyword">new</span> BwmFIveSeriesGearbox(<span class="string">"8挡手自一体"</span>);
}
}
</code></pre><p>X6：</p>
<pre><code> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BwmXSixFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span> </span>{
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> CarFrame <span class="title">createCarFrame</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> BwmXSixCarFrame(<span class="string">"中大型SUV"</span>,<span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">4929</span>,<span class="number">1983</span>,<span class="number">1709</span>},<span class="string">"5门5座SUV"</span>);
    }
   <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> BwmXSixEngine(<span class="string">"3.0T"</span>);
   }
   <span class="annotation">@Override</span>
     <span class="function"><span class="keyword">public</span> Gearbox <span class="title">createGearbox</span><span class="params">()</span> </span>{
       <span class="keyword">return</span> <span class="keyword">new</span> BwmXSixGearbox(<span class="string">"8挡手自一体"</span>);
   }
}
</code></pre><p>程序写到这里也快结束了，我们自己在写一个汽车超市来生成这些对象就好了，希望你有一次愉快的购物经历，哈哈～</p>
<h2 id="总结">总结</h2><p>在抽象工厂模式的运用中，需要有一个总的抽象工厂，这个工厂制造可以生产具体东西的工厂类，比如，CarFactory和BwmXSixFactory之间的关系。然后就是接口的运用。接口对于高抽象层级的类有很大作用，站在高处便能规定对继承该接口的类的行为，但并不具体到每一个继承的类的行为。最后，工厂模式成功的隐藏了类的行为，满足迪米特法则，调用者根本不关心怎么实现的，只要一个接口可以调用便行。</p>
<p>自己在设计模式这一块还比较弱，以后还需多多学习。设计模式每一个都不是太难，重要的是各个击破之后，将他们拿捏在手中能够灵活的运用到实例的工作中。所以，重要的还是自己能力的提升，加油～</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在学习设计模式的路上越走越远…</p>
<p>今天主要记录记录一下学习的工厂模式。</p>
<h2 id="工厂模式简历">工厂模式简历</h2><h3 id="1、由来">1、由来　　　　</h3><p>当我们创建一个对象，而这个对象的创建过程序纷繁复杂，可能导致大量]]>
    </summary>
    
      <category term="java" scheme="http://wfsovereign.github.io/tags/java/"/>
    
      <category term="工厂模式" scheme="http://wfsovereign.github.io/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://wfsovereign.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://wfsovereign.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅析javascript原型与对象]]></title>
    <link href="http://wfsovereign.github.io/2015/02/06/%E6%B5%85%E6%9E%90javascript%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>http://wfsovereign.github.io/2015/02/06/浅析javascript原型与对象/</id>
    <published>2015-02-06T06:24:00.000Z</published>
    <updated>2015-10-26T13:52:01.656Z</updated>
    <content type="html"><![CDATA[<p>在我学习与使用javascript三个月中，我一直对javascript的继承关系以及prototype理解不清，导致很多时候为什么这么用说不出个所以然来。截止到本周为止，通过之前的学习以及自己的再学习，自我感觉算是对这一块有了较为清晰的认识，此文将谈谈我对javascript原型与继承的理解，在此之前，我们首先要知道一些基本的知识。 </p>
<h2 id="知识铺垫">知识铺垫</h2><h3 id="1、数据类型">1、数据类型</h3><p>JavaScript中的数据类型在曾经我也有提到过，它包括未定义值（undefined），空值（null），布尔值（boolean），数字（number），字符串（string）以及对象（object），而对象中又包含特殊对象数组（array），并且函数也是对象。其中，字符串（string），对象（object）等都是由构造函数来实现的。讲到这里又得说说JavaScript中的函数了。</p>
<h3 id="2、函数">2、函数</h3><p>就我所知的语言都是有函数这个概念的，所以就不再细说。在 JavaScript 中函数也是一个对象，那么对象又是通过什么来创建的呢？对象是作为现有示例（即原型）对象的副本而创建的，该名称就来自于这一概念，此原型对象的任何属性和方法都将显示为从原型的构造函数创建的对象的属性和方法。可以说，这些对象从其原型继承了属性和方法。</p>
<p>普通的函数与构造函数在JavaScript中都是通过function来创建，不同的是构造函数需要通过大写来标明。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'my name is '</span> + <span class="keyword">this</span>.name + <span class="string">",I'm "</span> + <span class="keyword">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.say_hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello,I'm"</span> + <span class="keyword">this</span>.sex)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype.is_alive = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wfsovereign = <span class="keyword">new</span> Person(<span class="string">'wfsovereign'</span>, <span class="number">21</span>, <span class="string">"boy"</span>);</span><br><span class="line"></span><br><span class="line">wfsovereign.say();  <span class="comment">//output my name is wfsovereign,I'm 21</span></span><br><span class="line"><span class="built_in">console</span>.log(wfsovereign.is_alive());     <span class="comment">//output true</span></span><br><span class="line"><span class="built_in">console</span>.log(wfsovereign.say_hello(), <span class="string">"----"</span>);    <span class="comment">//output undefined</span></span><br></pre></td></tr></table></figure>
<p>此例中，创建了构造函数Person，接受参数为name，age，拥有静态方法say_hello（），实例方法say（）和is_alive（），使用构造函数创建实例对象wfsovereign，能够调用实例方法，调用静态方法时提示未定义。</p>
<p>在构造函数后通过”.”来添加的方法或属性，称之为静态方法或静态属性，这是实例之后的对象不能访问的。因此，我们通过wfsovereign调用say_hello（）时才会提示undefined。</p>
<p>那么，我们写在构造函数的prototype上的方法is_alive（）为什么实例过后仍然能够被访问呢？这个问题我们先放放，先来看看实例对象与构造函数间的联系，通过控制台，我们输出</p>
<pre><code><span class="tag">console</span><span class="class">.log</span>(<span class="tag">wfsovereign</span><span class="class">.prototype</span>);
<span class="tag">console</span><span class="class">.log</span>(<span class="tag">wfsovereign</span><span class="class">.__proto__</span>);
<span class="tag">console</span><span class="class">.log</span>(<span class="tag">wfsovereign</span><span class="class">.constructor</span>);
</code></pre><p>可以看到</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span>    <span class="comment">//wfsovereign.prototype</span></span><br><span class="line">Person&#123;</span><br><span class="line">    is_alive: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;    <span class="comment">//wfsovereign.__proto__)</span></span><br><span class="line">&#123;</span><br><span class="line">    constructor: <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">        is_alive: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            __proto__: <span class="built_in">Object</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;   <span class="comment">//wfsovereign.constructor</span></span><br><span class="line">                <span class="keyword">this</span>.name = name;</span><br><span class="line">                <span class="keyword">this</span>.age = age;</span><br><span class="line">                <span class="keyword">this</span>.sex = sex;</span><br><span class="line">                <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'my name is '</span> + <span class="keyword">this</span>.name + <span class="string">",I'm "</span> + <span class="keyword">this</span>.age)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，实例对象wfsovereign没有prototype属性，但是有了指向构造函数Person.prototype的<strong>proto</strong>属性以及指向构造函数的constructor属性，而Person这一构造函数也有指向object的<strong>proto</strong>属性，说明Person也是通过object创建的一个实例。这个时候我相信聪明如你就能回答上面提出的问题了—我们写在构造函数的prototype上的方法is_alive（）为什么实例过后仍然能够被访问呢？</p>
<p>由此，我们得出，创建的每一个函数都有prototype属性，这是一个指针，它指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。也就是说prototype是通过调用构造函数而创建的那个对象实例的原型对象，并且只有函数才有prototype属性，实例的对象没有该属性，即这里用Person创建的实例wfsovereign是没有prototype这一属性的。</p>
<p>当使用构造函数（Person）创建一个实例（wfsovereign）的时候，实例内部将包含一个内部指针（<strong>proto</strong>)指向构造函数的prototype，这个连接存在于实例和构造函数的prototype之间，而不是实例与构造函数之间，实例与构造函数之间通过constructor连接。知道了prototype是什么和怎么来的之后，我们再来看JavaScript的原型链就容易多了。</p>
<h2 id="继承与原型链">继承与原型链</h2><h3 id="1、原型链的理解">1、原型链的理解</h3><p>JavaScript 不包含传统的类继承模型，而是使用 prototype 原型模型。在JavaScript中，一共有两种类型的值,原始值和对象值。每个对象都有一个内部属性 prototype ,我们通常称之为原型。原型的值可以是一个对象，也可以是null。如果它的值是一个对象，则这个对象也一定有自己的原型。当从一个对象那里调取属性或方法时，如果该对象自身不存在这样的属性或方法，就会自己去关联的prototype对象那里寻找，如果prototype没有，就会去关联的创造者那里找，直到prototype为undefined为止，Object的prototype就是undefined即所有原型都终止于 Object.prototype，这样就形成了一条线性的链，我们称之为原型链。JavaScript正是通过原型链来调用关联创造者的属性与方法的即继承。</p>
<h3 id="2、使用原型的好处">2、使用原型的好处</h3><p>可以让对象实例共享它所包含的属性和方法。也就是说，不必在构造函数中添加定义对象信息，而是可以直接将这些信息添加到原型中，通过指针引用的方式来调用。使用构造函数的主要问题就是每个方法都要在每个实例中创建一遍。</p>
<p>　　</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在我学习与使用javascript三个月中，我一直对javascript的继承关系以及prototype理解不清，导致很多时候为什么这么用说不出个所以然来。截止到本周为止，通过之前的学习以及自己的再学习，自我感觉算是对这一块有了较为清晰的认识，此文将谈谈我对javascri]]>
    </summary>
    
      <category term="javascript" scheme="http://wfsovereign.github.io/tags/javascript/"/>
    
      <category term="原型" scheme="http://wfsovereign.github.io/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="对象" scheme="http://wfsovereign.github.io/tags/%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="javascript" scheme="http://wfsovereign.github.io/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ignore文件的创建与使用]]></title>
    <link href="http://wfsovereign.github.io/2014/12/26/ignore%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://wfsovereign.github.io/2014/12/26/ignore文件的创建与使用/</id>
    <published>2014-12-26T07:39:00.000Z</published>
    <updated>2015-10-26T13:52:16.639Z</updated>
    <content type="html"><![CDATA[<p>在我们使用github提交本地代码时，有些库文件和日志文件是不必要提交的，那如何处理这个问题呢？这个时候我们就会用到.gitignore文件了。这里我会介绍如何创建.gitignore，以及如何处理已提交的不必要的项目文件。此次工作环境是基于ubuntu14.04。</p>
<h3 id="创建">创建</h3><p>首先,.gitignore文件应该是创建在你的项目的根目录下面的，你可以使用</p>
<blockquote>
<p>vim .gitignore </p>
</blockquote>
<p>或者是</p>
<blockquote>
<p>gedit .gitignore</p>
</blockquote>
<p>例如我的一个.gitignore文件如下:</p>
<pre><code>node_modules 
<span class="built_in">dist</span>
.tmp
bower_components
test
<span class="keyword">public</span>
</code></pre><p>这些文件都是库文件以及自动生成的模块，都是不必要提交的。下面我会讲一个关于已提交不必要文件的处理。</p>
<h3 id="对已提交不必要文件的处理方法">对已提交不必要文件的处理方法</h3><p>有时候当我们明白这个gitignore之后才发现我们已经提交不必要的文件了，而自己又是一个较完美主义者，不愿意让那些文件存在我们库里，该怎么做呢？有什么办法吗？办法肯定是有的。</p>
<p>那么我们现在预设的问题模型是：项目文件里有一个node_modules文件，该文件是存储自动生成的模型的文件，然后我已经把这个文件提交到github库里了，现在我明白了这个道里过后想删掉它并且以后都不再提交它。处理的方法：首先，我们再终端进入项目的根文件下面，创建.gitignore文件，并且添加需要忽略提交的文件，如上面我的一个.gitignore文件，然后输入如下命令</p>
<blockquote>
<p>git rm -r –cached node_modules（要删除的文件名）</p>
</blockquote>
<p>然后再</p>
<blockquote>
<p>git push</p>
</blockquote>
<p>最后我们去我们的github的库里去就会发现刚刚删除的东西已经成功删除啦~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在我们使用github提交本地代码时，有些库文件和日志文件是不必要提交的，那如何处理这个问题呢？这个时候我们就会用到.gitignore文件了。这里我会介绍如何创建.gitignore，以及如何处理已提交的不必要的项目文件。此次工作环境是基于ubuntu14.04。</p>]]>
    </summary>
    
      <category term="git" scheme="http://wfsovereign.github.io/tags/git/"/>
    
      <category term="ignore" scheme="http://wfsovereign.github.io/tags/ignore/"/>
    
      <category term="git" scheme="http://wfsovereign.github.io/categories/git/"/>
    
  </entry>
  
</feed>
