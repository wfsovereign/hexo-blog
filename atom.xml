<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[wfsoverign'notes]]></title>
  <subtitle><![CDATA[A love world boy]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://wfsovereign.github.io/"/>
  <updated>2015-10-31T13:03:55.119Z</updated>
  <id>http://wfsovereign.github.io/</id>
  
  <author>
    <name><![CDATA[wfsovereign]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Linux学习之文件操作]]></title>
    <link href="http://wfsovereign.github.io/2015/10/31/learn-shell-operate-file/"/>
    <id>http://wfsovereign.github.io/2015/10/31/learn-shell-operate-file/</id>
    <published>2015-10-31T13:01:59.000Z</published>
    <updated>2015-10-31T13:03:55.119Z</updated>
    <content type="html"><![CDATA[<h3 id="mkdir">mkdir</h3><p>The mkdir command is used to create directories.It works like this:</p>
<p>mkdir命令是用来创建目录的，这样使用：</p>
<blockquote>
<p>mkdir directory…</p>
</blockquote>
<p><strong>A note on notation:</strong> When three periods follow an argument in the description of a command(as above),it means that the argument can be repeated,thus:</p>
<p>注意表示法：当遇见一个后面有三个圆点的命令（如上所示），这表示那个参数可以重复：</p>
<blockquote>
<p>  tmp  mkdir max<br>➜  tmp  ls<br>a.json                   max                      server.js</p>
<p>➜  tmp  mkdir max1 max2 max3<br>➜  tmp  ls<br>a.json                   max1                     reade_file.js<br>clone_obj.js             max2                     server.js<br>getIp.js                 max3                     </p>
</blockquote>
<h3 id="cp">cp</h3><p>The cp command copies files or directories. It can be used two different ways:</p>
<p>cp命令，复制文件或目录，它有两种使用方法：</p>
<blockquote>
<p>cp file1 file2</p>
</blockquote>
<p>to copy the single file or directory “file1” to file or directory “file2” and :</p>
<p>复制单个文件或目录，和：</p>
<blockquote>
<p>cp file… directory</p>
</blockquote>
<p>to copy multiple files(either files or directories)into a direcotory.</p>
<p>复制多个文件或目录到一个目录下。</p>
<h3 id="mv">mv</h3><p>The mv command performs both file moving and file renaming, depending on how it is used. In erther case,the original filename no longer exists after the operation. mv is used in much the same way as cp:</p>
<p>mv命令可执行文件移动以及文件重命名两种任务，这依赖于如何使用它。任何一种情况下，在此操作之下原始文件都将不再存在。mv命令使用方法同cp一样：</p>
<blockquote>
<p>mv file1 file2</p>
<p>mv file1 file2 file3 code</p>
</blockquote>
<h3 id="rm">rm</h3><p>The rm command is used to remove(delete) files and directories:</p>
<p>rm命令用来删除文件或者目录：</p>
<blockquote>
<p>rm file…</p>
</blockquote>
<p>###Options<br>| Option | meaning |<br>|——–|——–|<br>|-r –recursive        |    recursive operation    |<br>|-f –force        |    force operation    |</p>
<h3 id="ln">ln</h3><p>The ln command is used to create either hard or symbolic links. It is used in one of two ways:</p>
<p>ln命令用来创建硬链接，也可以创建符号链接。可以用其中一种方法使用它：</p>
<blockquote>
<p>ln file link</p>
</blockquote>
<p>to create a hard link, and:</p>
<p>创建硬链接，和：</p>
<blockquote>
<p>ln -s item link</p>
</blockquote>
<p>to create a aymbolic link “item” is erther a file or a directory.</p>
<p>创建符号链接，“item”可以是一个文件或是一个目录。</p>
<h3 id="hard_link">hard link</h3><p>Hard links are the original Unix way of creating links, compared to symbolic links, which are more modern. By default, every file has a single hard link that gives the file its name. When we create a hard link, we create an additional directory entry for a file. Hard links have two important limitations:</p>
<p>硬链接最初是Unix创建的一种链接方式，和符号链接比起来，而符号链接更加现代.在默认方式下，每个文件有一个硬链接，这个硬链接就是文件的别名。当我们创建一个硬链接时，我们也就为这个文件创建一个额外的入口。硬链接有两个重要的局限性：</p>
<ol>
<li>A hard link cannot reference a file outside its own file system. This means a link may not reference a file that is not on the same dis partition as the link itself.</li>
<li><p>A hard link may not reference a directory.</p>
</li>
<li><p>一个硬链接不能关联一个它所在文件系统之外的文件。这是说一个链接不能关联与链接本身不再同一个磁盘分区上的文件。</p>
</li>
<li>一个硬链接不能关联一个目录。</li>
</ol>
<h3 id="symbolic_link">symbolic link</h3><p>Symbolic links were created to overcome the limitations of hard links. Symbolic links work by creating a special type of file that contains a text pointer to the referenced file or directory.In this regard, they operate in much the same way as a Windows shortcut though of course, they predate the Windows feature by many years.</p>
<p>符号链接的创建是为了克服硬链接的局限性。符号链接通过创建一个包含指向关联的文件或目录的文本指针的特别的文件类型来工作。在这一方面，他们和Windows的快捷方式差不多，当然，符号链接早于Windows的快捷方式很多年。</p>
<p>A file pointed to by a symbolic link, and the symbolic link itself are largely indistinguishable from one another. For example, if you write some something to symbolic link, the referenced file is also written to. However when you delete a symbolic link, only the link is deleted, not the file itself. If the file is deleted before the symbolic link, the link will continue to exist, but will point to nothing. In this case, the link is said to be broken. In many implementations, the ls command will display broken links in a distinguishing color, such as red, to reveal their presence.</p>
<p>一个符号链接指向一个文件，而这个符号链接本身与其他的符号链接几乎没有区别。比如，如果你向一个符号链接里写入一些东西，那么关联的文件也会被写入。然而当你删除一个符号链接时，仅仅这个链接被删除，不会影响到文件本身。如果这个文件在符号链接之前被删除了，这个链接将会继续存在，但不会指向任何东西。这种情况下，这个链接被称为坏链接。在许多实现中，ls命令会以可区分的颜色来显示这些坏链接，比如红色，来显示他们的存在。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="mkdir">mkdir</h3><p>The mkdir command is used to create directories.It works like this:</p>
<p>mkdir命令是用来创建目录的，这样使用：</p>
<blockquote]]>
    </summary>
    
      <category term="linux" scheme="http://wfsovereign.github.io/tags/linux/"/>
    
      <category term="文件" scheme="http://wfsovereign.github.io/tags/%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux学习之探索文件系统]]></title>
    <link href="http://wfsovereign.github.io/2015/10/28/learn-shell-explore-file-system/"/>
    <id>http://wfsovereign.github.io/2015/10/28/learn-shell-explore-file-system/</id>
    <published>2015-10-28T12:57:54.000Z</published>
    <updated>2015-10-31T13:03:38.967Z</updated>
    <content type="html"><![CDATA[<h3 id="ls">ls</h3><p>With it, we can see directory contents and determine a variety of important file and directory attributes.</p>
<p>通过它，我们可以看见目录的内容、重要的文件和目录属性</p>
<blockquote>
<p>~  ls<br>Applications   Downloads      Music          VirtualBox VMs company<br>Desktop        Library        Pictures       build          doc<br>Documents      Movies         Public         code           system<br>➜  ~</p>
</blockquote>
<p>Besides the current working directory,we can specify the directory to list,like so:</p>
<p>除了当前工作目录外，还可以指定别的目录，像这样：</p>
<blockquote>
<p>ls ./code<br>N-chat           crawl-info       muying           npm_ref_wf_test  test<br>cn_admin_backend geoip-cn         node-geoip       npm_test999      tmp<br>cn_backend       mail_test        nodeclub         personal         zhongzhong<br>➜  ~</p>
</blockquote>
<p>Or even specify multiple directories. In this example we will list both the user’s home directory(symbolized by the “~” character) and the code directory:</p>
<p>甚至可以列出多个目录的内容，在这个例子中，将会列出home目录和code目录的内容：</p>
<blockquote>
<p>  ~  ls ~ ./code<br>./code:<br>N-chat           crawl-info       muying           npm_ref_wf_test  test<br>cn_admin_backend geoip-cn         node-geoip       npm_test999      tmp<br>cn_backend       mail_test        nodeclub         personal         zhongzhong</p>
</blockquote>
<p>/Users/shining3d-fyqj:<br>Applications   Downloads      Music          VirtualBox VMs company<br>Desktop        Library        Pictures       build          doc<br>Documents      Movies         Public         code           system<br>➜  ~</p>
<p>Most commands use options consisting of a single character preceded by a dash, for example, “-l”, but many commands, including those from the GUN project, also support long options, consisting of a word preceded by two dashes. Also, many commands allow multiple short options to be strung together. In this example, the ls command is given two options, the “l” options to produce long format output, and the “t” option to sort the result by the file’s modification time.</p>
<p>大多数命令使用的选项是使用一个中划线加一个字符组成，例如“l”，但是许多命令，包括来自于UGN项目的命令，也支持长选项，长选项是由两个中划线加一个单词组成。当然，许多命令允许使用多个短选项串一起使用。下面这个例子有两个选项，“l”产生长格式输出，“t”得到按修改时间的先后顺序排序的结果。</p>
<blockquote>
<p>➜  ~  ls -lt<br>total 0<br>drwx——+ 50 shining3d-fyqj  staff  1700 10 28 11:13 Downloads<br>drwxr-xr-x   8 shining3d-fyqj  staff   272 10 27 10:38 company<br>drwxr-xr-x   4 shining3d-fyqj  staff   136 10 26 17:20 VirtualBox VMs<br>drwxr-xr-x   4 shining3d-fyqj  staff   136 10 26 16:44 system<br>drwx——@ 53 shining3d-fyqj  staff  1802 10 26 16:26 Library<br>drwxr-xr-x  18 shining3d-fyqj  staff   612 10 26 14:03 code<br>drwx——+  5 shining3d-fyqj  staff   170 10 21 11:07 Pictures<br>drwxr-xr-x   9 shining3d-fyqj  staff   306 10 20 16:35 doc<br>drwxr-xr-x   4 shining3d-fyqj  staff   136 10 20 14:41 build<br>drwx——+  4 shining3d-fyqj  staff   136 10 16 09:14 Music<br>drwx——+  5 shining3d-fyqj  staff   170  9 24 15:24 Desktop<br>drwx——+ 10 shining3d-fyqj  staff   340  9 21 14:55 Documents<br>drwx——   4 shining3d-fyqj  staff   136  8 17 10:31 Applications<br>drwx——+  3 shining3d-fyqj  staff   102  8 17 10:26 Movies<br>drwxr-xr-x+  5 shining3d-fyqj  staff   170  8 17 10:26 Public<br>➜  ~</p>
</blockquote>
<p>We’ll add the long option “–reverse” to reverse the order of the sort:</p>
<p>得到的结果中还有delete权限的信息</p>
<blockquote>
<p>➜  ~  ls -lt -reverse<br>total 0<br>0 drwxr-xr-x+  5 shining3d-fyqj  staff   170  8 17 10:26 Public<br> 0: group:everyone deny delete<br>0 drwx——+  3 shining3d-fyqj  staff   102  8 17 10:26 Movies<br> 0: group:everyone deny delete<br>0 drwx——   4 shining3d-fyqj  staff   136  8 17 10:31 Applications<br>0 drwx——+ 10 shining3d-fyqj  staff   340  9 21 14:55 Documents<br> 0: group:everyone deny delete<br>0 drwx——+  5 shining3d-fyqj  staff   170  9 24 15:24 Desktop<br> 0: group:everyone deny delete<br>0 drwx——+  4 shining3d-fyqj  staff   136 10 16 09:14 Music<br> 0: group:everyone deny delete<br>0 drwxr-xr-x   4 shining3d-fyqj  staff   136 10 20 14:41 build<br>0 drwxr-xr-x   9 shining3d-fyqj  staff   306 10 20 16:35 doc<br>0 drwx——+  5 shining3d-fyqj  staff   170 10 21 11:07 Pictures<br> 0: group:everyone deny delete<br>0 drwxr-xr-x  18 shining3d-fyqj  staff   612 10 26 14:03 code<br>0 drwx——@ 53 shining3d-fyqj  staff  1802 10 26 16:26 Library<br> 0: group:everyone deny delete<br>0 drwxr-xr-x   4 shining3d-fyqj  staff   136 10 26 16:44 system<br>0 drwxr-xr-x   4 shining3d-fyqj  staff   136 10 26 17:20 VirtualBox VMs<br>0 drwxr-xr-x   8 shining3d-fyqj  staff   272 10 27 10:38 company<br>0 drwx——+ 50 shining3d-fyqj  staff  1700 10 28 11:13 Downloads<br> 0: group:everyone deny delete<br>➜  ~</p>
</blockquote>
<h3 id="file">file</h3><p>As we explore the system it will be useful to know what files contain. To do this we will use the file command to determine a file’s type. We can invoke the file command this way:</p>
<p>随着探索文件系统的进行，知道文件信息是很有用的，可用file命令达此目的。我们可以这样调用：</p>
<blockquote>
<p>➜  tmp  file server.js<br>server.js: UTF-8 Unicode text</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="ls">ls</h3><p>With it, we can see directory contents and determine a variety of important file and directory attributes.</p>
<p>通过它，]]>
    </summary>
    
      <category term="shell" scheme="http://wfsovereign.github.io/tags/shell/"/>
    
      <category term="文件" scheme="http://wfsovereign.github.io/tags/%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[New Begin]]></title>
    <link href="http://wfsovereign.github.io/2015/10/25/new-begin/"/>
    <id>http://wfsovereign.github.io/2015/10/25/new-begin/</id>
    <published>2015-10-25T12:17:37.000Z</published>
    <updated>2015-10-25T14:59:33.129Z</updated>
    <content type="html"><![CDATA[<p>时隔半年之久，终于，我又拾起了blog。</p>
<hr>
<p>自去年十月份开始正式走上程序员这条道路起，学习也一年有余。由一次意外得到的消息加入Thoughtworks的培训项目– Thoughtworks Academy，在这里，自学两月javascript、html、css等前端基础，然后在仝老师、玉姐、硕哥等的辅导下，接触互联网技术的最前沿思想，学习Thoughtworks的软件制作流程、TDD开发模式、团队合作，收获了很多…这段日子让我能够独立的去面对新技术而游刃有余，时常想念这段美好的日子，好想你们啊～</p>
<p>接着便是大四去公司完成实习任务，但在这个公司用的却是java，做的工作也是后端sql维护等，同事相对来说没有那种学习的朝气，与我当初进入这个领域所接受的思想完全不符，不开心，而作为程序员来说，不开心意味着就不会长久。因此，在七月底的时候，舍弃了很多，克服了很多，还是坚持了自己的选择，离开公司，去远方，做自己想做的工作。我觉得，男人就是该拼一拼，哈哈</p>
<p>杭州，初来乍到，请多指教。一个人来到杭州，诸多不便，但是在公司的工作却让我动力十足，做着自己喜欢的事情，几乎感觉不到疲惫。每晚八九点下班回家还能再写写自己的项目，那股兴奋劲自己都害怕，虽然时常顶着个黑眼圈，哈哈哈</p>
<p>blog很久没开更了，这段时间做了很多东西，也没来得及总结，就趁着这篇New Begin，慢慢的沉淀吧～</p>
<p>Let’s go！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>时隔半年之久，终于，我又拾起了blog。</p>
<hr>
<p>自去年十月份开始正式走上程序员这条道路起，学习也一年有余。由一次意外得到的消息加入Thoughtworks的培训项目– Thoughtworks Academy，在这里，自学两月javascript、html]]>
    </summary>
    
      <category term="成长" scheme="http://wfsovereign.github.io/tags/%E6%88%90%E9%95%BF/"/>
    
      <category term="独立" scheme="http://wfsovereign.github.io/tags/%E7%8B%AC%E7%AB%8B/"/>
    
      <category term="经历" scheme="http://wfsovereign.github.io/categories/%E7%BB%8F%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式之代理模式]]></title>
    <link href="http://wfsovereign.github.io/2015/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://wfsovereign.github.io/2015/04/22/设计模式之代理模式/</id>
    <published>2015-04-22T08:39:00.000Z</published>
    <updated>2015-10-26T14:20:40.272Z</updated>
    <content type="html"><![CDATA[<p>该篇讲主要讲述我学习代理模式的心得记录。</p>
<h2 id="代理模式基本属性">代理模式基本属性</h2><h3 id="1、定义">1、定义</h3><p>一个类可以作为其它东西的接口。代理者可以作任何东西的接口：网络连接、存储器中的大对象、文件或其它昂贵或无法复制的资源。而代理又分为静态代理和动态代理，其中动态代理具有更强的灵活性，不用在我们设计实现的时候就指定某一个代理类来代理哪一个被代理对象，而是把这种实现推迟到程序运行时。</p>
<h3 id="2、应用场景">2、应用场景</h3><p>功能需要被授予不同的权限时，如，注册与未注册的用户。</p>
<h3 id="3、优点">3、优点</h3><p>一个复杂对象可以由多个代理来引用，这样便节省了系统资源。</p>
<h2 id="实例讲解">实例讲解</h2><h3 id="1、静态代理">1、静态代理</h3><p>首先定义一个抽象类AbstractObject并在其内部定义一个抽象的方法，作为代理和被代理类的父类，</p>
<pre><code> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractObject</span> {
  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span>(<span class="params"></span>)</span>;
}
</code></pre><p>，然后创造一个继承了此父类的被代理类，</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">RealObject</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractObject</span> {</span>
  <span class="annotation">@Override</span>
  public void operation(){
      <span class="type">System</span>.out.println(<span class="string">"some operation"</span>);
 }
 }
</code></pre><p>再创造一个代理类，</p>
<pre><code> public <span class="class"><span class="keyword">class</span> <span class="title">ProxyObject</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractObject</span> {</span>
   <span class="type">RealObject</span> realObject = <span class="keyword">new</span> <span class="type">RealObject</span>();
 <span class="annotation">@Override</span>
     public void operation() {
       <span class="type">System</span>.out.println(<span class="string">"before"</span>);
       realObject.operation();
       <span class="type">System</span>.out.println(<span class="string">"after"</span>);
   }
}
</code></pre><p>在代理类中创建了一个父类，并且在重写的方法中调用了被代理类的同名方法。这便实现了一个简单的静态代理。</p>
<p>回顾一下思路，它实现一个共有的抽象类，代理与被代理均继承于这个类，在代理类中构造被代理类作为一个私有成员，并且在重写的方法中调用被代理类中重写的方法，并且可在该方法中添加自己的行为，最后客户端调用代理类中他们的共有接口，实现代理操作。</p>
<p>感觉和装饰者模式有些类似，均实现了相同的接口，通过调用底层的类来实现他们的功能。不过装饰者模式是将被装饰者作为参数传入，而静态代理是作为自己的私有成员变量。</p>
<h3 id="2、动态代理">2、动态代理</h3><p>我们采用定义接口的方式来实现，首先定义一个接口AbstractSubject，</p>
<pre><code> <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">AbstractSubject</span> {
  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">request</span>(<span class="params"></span>)</span>;
}
</code></pre><p>接着就是我们被代理的对象，</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">AbstractSubject</span> </span>{
 <span class="annotation">@Override</span>
 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span>
 </span>{
     System.out.println(<span class="string">"real subject's request()........"</span>);
 }
}
</code></pre><p>在被代理类中我们重写了接口中定义的方法，接着再实现最重要的代理类，</p>
<pre><code>public class <span class="type">DynamicProxy</span> implements 
<span class="type">InvocationHandler</span> {
     <span class="type">Object</span> beProxy = null;
 public <span class="type">DynamicProxy</span>(<span class="type">Object</span> beProxy){
     this.beProxy = beProxy;
    }
     @<span class="type">Override</span>
   public <span class="type">Object</span> invoke(<span class="type">Object</span> o, <span class="type">Method</span> <span class="keyword">method</span>, <span class="type">Object</span>[] objects) throws <span class="type">Throwable</span> {
       <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"before ----------"</span>+<span class="keyword">method</span>);
      <span class="type">Object</span> <span class="literal">result</span> = <span class="keyword">method</span>.invoke(this.beProxy,objects);
      <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"after ----------"</span>+<span class="keyword">method</span>);
        <span class="keyword">return</span> <span class="literal">result</span>;
  }
}
</code></pre><p>在这个代理类中，我们有一个需要传入被代理类对象的构造方法，而它实现的接口是系统自带的InvocationHandler，并且重写了invoke（）方法。最后，我们来看一下，我们是怎么使用这个代理的，</p>
<pre><code>  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DynamicProxyClient</span> {
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>{
        AbstractSubject realSubject = <span class="keyword">new</span> RealSubject();
        ClassLoader loader = realSubject.getClass().getClassLoader();
      Class&lt;?&gt;[] interfaces = realSubject.getClass().getInterfaces();

     InvocationHandler dynamicProxyHandler = <span class="keyword">new</span> DynamicProxy(realSubject);

AbstractSubject proxy = (AbstractSubject) Proxy.newProxyInstance(loader, interfaces, dynamicProxyHandler);
        proxy.request();
    }
 }
</code></pre><p>　　　　<br>使用java原生的Proxy类与InvocationHandler接口，通过自己所写的DynamicProxy实现InvocationHandler接口，在程序运行时，newProxyInstance（）方法通过接收类加载器ClassLoader，动态代理类所实现的接口interface以及实现了InvocationHandler接口的动态类实例DynamicProxy，创建一个动态代理proxy。</p>
<p>其中，在DynamicProxy类中重写的invoke（）方法，则是动态代理所必须执行的，因为Proxy.newProxyInstance（）方法返回的是一个继承于Proxy的子类对象，通过调用该对象的代理方法，会执行父对象中InvocationHandler成员的invoke（）方法，因此，最终执行了我们在DynamicProxy中重写的invoke（）方法。关于最后proxy调用request（）方法为什么就能执行到被代理类的方法，这里我再做一次说明。因为proxy是属于Proxy类的，因为他的类是com.sun.proxy.$Proxy0，是继承了Proxy类的，而在$Proxy0中重写了request（）方法，并且调用了父类中h的invoke方法，而在父类Proxy中，h是这样定义的，</p>
<pre><code><span class="keyword">protected</span> InvocationHandler h;
</code></pre><p>也就是说调用的是InvocationHandler.invoke（）方法，而DynamicProxy又实现了InvocationHandler接口的invoke（）方法，因此，最后调用的便是DynamicProxy中的invoke（）方法。这也就是java内置的动态代理实现机制。</p>
<h2 id="总结">总结</h2><p>学习了该模式之后，有了些感悟。设计模式，究其本质，就是一些方式方法，并且是适合面向对象这种语言的方法，我们通过这些方法能够顺利的达到我们所需要的目的，并且能够让我们的代码结构变得更清晰，更具逻辑。这便是设计模式的目的吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>该篇讲主要讲述我学习代理模式的心得记录。</p>
<h2 id="代理模式基本属性">代理模式基本属性</h2><h3 id="1、定义">1、定义</h3><p>一个类可以作为其它东西的接口。代理者可以作任何东西的接口：网络连接、存储器中的大对象、文件或其它昂贵或无法复制]]>
    </summary>
    
      <category term="java" scheme="http://wfsovereign.github.io/tags/java/"/>
    
      <category term="代理模式" scheme="http://wfsovereign.github.io/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://wfsovereign.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://wfsovereign.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://wfsovereign.github.io/2015/04/06/hello-world/"/>
    <id>http://wfsovereign.github.io/2015/04/06/hello-world/</id>
    <published>2015-04-06T12:17:37.000Z</published>
    <updated>2015-10-25T13:59:11.013Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <link href="http://wfsovereign.github.io/2015/03/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://wfsovereign.github.io/2015/03/28/设计模式之单例模式/</id>
    <published>2015-03-28T08:40:00.000Z</published>
    <updated>2015-10-26T14:10:37.100Z</updated>
    <content type="html"><![CDATA[<p>各个模式均有自己的出现的理由以及应用场景，相较于普通代码有一定的优势的时候的，设计模式便也应运而生了。今天所要记录的单例模式，它的优势在哪呢？</p>
<h2 id="单例模式简历">单例模式简历</h2><h3 id="1、出生原因">1、出生原因</h3><p>当我们在一个管理者管辖范围不明确，各个部门间的领导互相插手彼此部门间的事物，员工一会被这个boss分配任务，一会被那个boss分配任务的公司里，作为一个普通员工，您怎么想？对于一个管理层这样混乱与模糊的公司，您怎么看？在一个项目中也一样，我们的某些类，一会被这个实例化，一会被那个实例化，而这个类的功能却是很单一的管理着同样一个领域，这个时候，你会不会想着做点什么来结束这个混乱的现象呢？重构、优化一下吧，特定的领域管理交由一个固定的对象来管理，那么，这个时候，单例模式就出现了。</p>
<h3 id="2、定义">2、定义</h3><p>单例对象的类必须保证只有一个实例存在，通过阻止外部实例化和修改，来控制所创建的对象的数量。</p>
<h3 id="3、适用情况">3、适用情况</h3><p>整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</p>
<h3 id="4、实现思路">4、实现思路</h3><p>一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</p>
<h3 id="5、亮点">5、亮点</h3><p>整个系统中只有这么一个实例对象，方便各处的运用，也方便管理该对象所要管理的东西。</p>
<h2 id="实例讲解">实例讲解</h2><p>接下来，我们通过三个不同层次的单例模式实例，来较为深入的理解在java代码中如何实现及其原理。</p>
<p>首先，在我们的level1包下面创建Singleton类，</p>
<pre><code>public class Singleton {
 <span class="keyword"> private</span><span class="keyword"> static</span> Singleton<span class="instruction"> instance </span> = null;
  <span class="keyword"> public</span><span class="keyword"> static</span> Singleton<span class="function"> getInstance(</span><span class="function">)</span>{
      <span class="function"> if(</span>instance == null<span class="function">)</span>{
         <span class="instruction"> instance </span>=<span class="instruction"> new </span>Singleton(<span class="function">)</span>;
      }
      <span class="instruction"> return </span>instance;
   }
   <span class="keyword"> private</span><span class="function"> Singleton(</span><span class="function">)</span> {}
   <span class="keyword"> public</span> void<span class="function"> doSomething(</span><span class="function">)</span>{
     <span class="function"> System.out.println(</span><span class="string">"'how are you'"</span><span class="function">)</span>;
  }
}
</code></pre><p>将Singleton的构造函数私有化，阻止外部实例化，再通过调用一个共有的接口getInstance（）方法，首先if（instance == null）判断其是否创建，再返回instance对象。这一切看起来都还挺不错的，一环接一环的保证了咱们Singleton类只返回一个实例化对象instance。可是真的是这样吗？让我们的大脑跑起A、B双线程来，假如当A准备创建instance的时候B正好进行if（）判断语句，这个时候instance == null 是要返回true的，那么，这种情况肯定就会创建两个instance对象了，所有，这个实现方法在多线程里，是不安全的单例模式，或者说多线程情况下，这种实现不合理。</p>
<p>那么，开动我们的大脑，想想办法来控制他的实例化判断。于是，会写出如下代码：</p>
<pre><code><span class="keyword"> public</span> class Singleton {
  <span class="keyword"> private</span><span class="keyword"> static</span> Singleton<span class="instruction"> instance </span>= null;
 <span class="keyword"> public</span><span class="keyword"> static</span> Singleton<span class="function"> getInstance(</span><span class="function">)</span> {
   <span class="instruction"> if </span>(instance == null<span class="function">)</span> {
      synchronized<span class="function"> (</span>Singleton.class<span class="function">)</span> {                   <span class="instruction"> if </span>(instance == null<span class="function">)</span> {
       <span class="instruction"> instance </span>=<span class="instruction"> new </span>Singleton(<span class="function">)</span>;
                 }
        }
      }
     <span class="instruction"> return </span>instance;
  }
   <span class="keyword"> private</span><span class="function"> Singleton(</span><span class="function">)</span> {
  }
 <span class="keyword"> public</span> void<span class="function"> doSomething(</span><span class="function">)</span> {
     <span class="function"> System.out.println(</span><span class="string">"'how are you'"</span><span class="function">)</span>;
  }
}
</code></pre><p>我们通过double-checked-locking的方法来阻止其多线程运行。当getInstance（）方法被调用的时候，首先进行null值检测，若是false直接返回instance，否则，运行同步锁，（synchronized，它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码），然后再进行null值检测，返回instance。这样，我们的程序就没有多线程情况下被多次创建的可能。感觉，程序写到这里，已经是很酷了，其实我也觉得，哈哈。不过，当我们了解创建一个变量的步骤时，可能就会有疑问了。</p>
<p>创建一个变量，有以下几个步骤：申请一块内存，调用构造方法进行初始化，分配一个指针指向这块内存。而这些都是JVM来执行，但是JVM仅仅是一个标准，没有规定编译器优化的内容，导致其可以自由进行优化，在不改变原来语义的情况下，通过调整语句顺序，来让程序运行的更快。那么，就有可能会出现这种情况：当A线程开始创建Singleton实例时，B线程调用getInstance（）方法检测null时，假如此时A已经将instance指向了那块内存，但还没有赋值，那么B线程检测null时会直接返回instance，但是instance的构造并没有完成，程序便出错了。</p>
<p>这可让我们很是懊恼，怎么感觉处处碰壁的样子，难道JAVA就不能安全的实现单例模式吗？结果肯定是有的，平下心来，我们来看看接下来的实现：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> {
   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>) </span>{
   }
     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SingletonInstance</span> {
       <span class="keyword">private</span> <span class="keyword">static</span> final Singleton instance = <span class="keyword">new</span> Singleton();
   }
     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>(<span class="params"></span>) </span>{
      <span class="keyword">return</span> SingletonInstance.instance;
  }   
  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>{
      System.<span class="keyword">out</span>.println(<span class="string">"'how are you'"</span>);
  }
}
</code></pre><p>使用java静态内部类，JVM能够保证当一个类被加载时，这个加载过程是互斥的。调用getInstance（）方法时，首先加载SingletonInstance类，这个类有一个static实例，所以需要调用Singleton的构造方法，最后getInstance将这个instance返回给使用者。</p>
<h2 id="总结">总结</h2><p>通过学习单例模式之后，感觉学习一门语言，仅仅浅显的学习是不够的，有时候，你仅仅知道怎么用，你可能永远都写不出好的程序，这不是危言耸听。据我所知，优秀的程序员，几乎都学习过编译原理，当然，信息来源于知乎，因为自己平时知乎浏览的要多一些。所以，编译原理，已经被我提上今后的日程表了。</p>
<p>设计模式这一块，可能得暂时停下来了，因为有了新的任务，不过剩下的一篇代理模式我会抽空更新的，这是我的承诺@杜珊</p>
<p><strong>加油吧，大家～！！</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>各个模式均有自己的出现的理由以及应用场景，相较于普通代码有一定的优势的时候的，设计模式便也应运而生了。今天所要记录的单例模式，它的优势在哪呢？</p>
<h2 id="单例模式简历">单例模式简历</h2><h3 id="1、出生原因">1、出生原因</h3><p>当我们在]]>
    </summary>
    
      <category term="java" scheme="http://wfsovereign.github.io/tags/java/"/>
    
      <category term="单例模式" scheme="http://wfsovereign.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://wfsovereign.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://wfsovereign.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式之工厂模式]]></title>
    <link href="http://wfsovereign.github.io/2015/03/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://wfsovereign.github.io/2015/03/23/设计模式之工厂模式/</id>
    <published>2015-03-23T07:23:00.000Z</published>
    <updated>2015-10-26T14:10:37.104Z</updated>
    <content type="html"><![CDATA[<p>最近在学习设计模式的路上越走越远…</p>
<p>今天主要记录记录一下学习的工厂模式。</p>
<h2 id="工厂模式简历">工厂模式简历</h2><h3 id="1、由来">1、由来　　　　</h3><p>当我们创建一个对象，而这个对象的创建过程序纷繁复杂，可能导致大量的重复代码的时候，工厂模式出现了。工厂方法模式通过定义一个单独的创建对象的方法来解决这些问题。由子类实现这个方法来创建具体类型的对象。也就是说，在我们的实际运用中，工厂就是一个用来创建其他对象的对象。</p>
<h3 id="2、实质">2、实质</h3><p>定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。</p>
<h3 id="3、现状介绍">3、现状介绍</h3><p>工厂模式目前有三个分支，简单工厂模式，工厂方法模式和抽象工厂方法模式，其中，我主要学习的是抽象工厂方法模式，因为该方法是工厂模式中最高层的方法。简单工厂模式，工厂类根据传参不同得到不同的产品。工厂方法模式能够创建这个系列中的各种产品，比如，iphone的各种配件。而抽象工厂模式作为更高级的模式，它可以创建整个苹果公司各个产品流水线，比如，他可以创建生产iphone配件的工厂，可以创建生产ipad配件的工厂等等。那么，抽象工厂模式与工厂方法模式的最大区别就在于，工厂方法模式针对的是一个产品等级结构，它能够创建这一个等级结构中的产品族；而抽象工厂模式则需要面对多个产品等级结构，也就是说，抽象工厂方法模式可以工厂方法模式中的工厂。</p>
<h3 id="4、三分支的关系">4、三分支的关系</h3><p>简单工厂模式通常伴随着对象的具体类型与工厂具体类型的一一对应，客户端代码根据需要选择合适的具体类型工厂使用。当这个选择包含复杂的逻辑时，就可以创建一个单一的工厂类，用以包含这种选择逻辑，根据参数的不同选择实现不同的具体对象。这个工厂类不需要由每个具体产品实现一个自己的具体的工厂类，所以可以将工厂方法设置为静态方法，这就有了工厂方法模式。而抽象工厂方法模式便是封装着这样一组有着共同主题的工厂方法模式中的工厂。</p>
<p>　　</p>
<h2 id="三分支的应用场景">三分支的应用场景</h2><h3 id="1、简单工厂模式">1、简单工厂模式</h3><p>当我们的主程序中需要自己手动初始化一个对象，但是我们并不想关注具体的初始化过程，这个时候简单工厂模式就是您的选择。</p>
<h3 id="2、工厂方法模式">2、工厂方法模式</h3><p>当你觉得传入参数的这种简单的工厂模式让你程序容易出错，并且程序中的if-else让你的程序看起来有些臃肿，这个时候工厂方法模式就是您的选择。</p>
<h3 id="3、抽象工厂方法模式">3、抽象工厂方法模式</h3><p>当你工厂类需要修改时，而在工厂方法模式中需要修改原有的工厂类，这就违背了设计原则中的OCP（开放闭合原则），这个时候，抽象工厂方法模式就是您的选择。 </p>
<h2 id="实际应用">实际应用</h2><p>说不如做，看的再多不自己亲手做一做来的有效率，这便是我学习工厂模式之后的心得。</p>
<p>首先，模拟场景。创建宝马车，X6和5系的，那么首先的有一个抽象的汽车工厂，CarFactory，由它来生成X6和5系的工厂，一个汽车工厂生产出来的汽车至少得有个壳，发动机，变速箱啥的，所有就有了方法。创建CarFactory如下：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">CarFactory</span> {
  <span class="function"><span class="keyword">public</span> CarFrame <span class="title">createCarFrame</span>(<span class="params"></span>)</span>;
  <span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span>(<span class="params"></span>)</span>;
  <span class="function"><span class="keyword">public</span> Gearbox <span class="title">createGearbox</span>(<span class="params"></span>)</span>;
 }
</code></pre><p>一个汽车的基本配件都出来了，那么所有的配件都应该有各自的接口，我们再分别创建Engine，Gearbox和CarFrame，Engine如下（Gearbox、CarFrame类似）：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Engine</span> {
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createEngine</span>(<span class="params"></span>)</span>;
 }
</code></pre><p>然后我们的X6和5系的都应该有这些个接口吧，我们在分别创建他们各自的Engine，Gearbox和CarFrame，X6的Engine：</p>
<pre><code> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BwmXSixEngine</span> <span class="keyword">implements</span> <span class="title">Engine</span> </span>{
     <span class="keyword">private</span> String emissions;
     <span class="function"><span class="keyword">public</span> <span class="title">BwmXSixEngine</span><span class="params">(String emissions)</span></span>{
         <span class="keyword">this</span>.emissions = emissions;
   }
<span class="annotation">@Override</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createEngine</span><span class="params">()</span> </span>{
     System.out.println(<span class="string">"this BWM XDrive engine,and emissions is "</span>+ <span class="keyword">this</span>.emissions);
     }
}
</code></pre><p>5系的Engine：</p>
<pre><code> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BwmFiveSeriesEngine</span> <span class="keyword">implements</span> <span class="title">Engine</span> </span>{
<span class="keyword">private</span> <span class="keyword">final</span> String emissions;
<span class="function"><span class="keyword">public</span> <span class="title">BwmFiveSeriesEngine</span><span class="params">(String emissions)</span></span>{
    <span class="keyword">this</span>.emissions = emissions;
    }
 <span class="annotation">@Override</span>
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createEngine</span><span class="params">()</span> </span>{
       System.out.println(<span class="string">"this is BWMFiveSeriesEngine it's emissions of "</span>+<span class="keyword">this</span>.emissions);
}
}
</code></pre><p>现在，X6和5系就只差装箱，我们就来创建他们的工厂吧，5系：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BwmFiveSeriesFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span></span>{
<span class="annotation">@Override</span>
 <span class="function"><span class="keyword">public</span> CarFrame <span class="title">createCarFrame</span><span class="params">()</span> </span>{
  <span class="keyword">return</span> <span class="keyword">new</span> BwmFiveSeriesCarFrame(<span class="string">"中大型车"</span>, <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">5047</span>,<span class="number">1860</span>,<span class="number">1491</span>},<span class="string">"4门5座三厢车"</span>);
}
<span class="annotation">@Override</span>
 <span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span> </span>{
      <span class="keyword">return</span> <span class="keyword">new</span> BwmFiveSeriesEngine(<span class="string">"2.0T"</span>);
  }
<span class="annotation">@Override</span>
<span class="function"><span class="keyword">public</span> Gearbox <span class="title">createGearbox</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="keyword">new</span> BwmFIveSeriesGearbox(<span class="string">"8挡手自一体"</span>);
}
}
</code></pre><p>X6：</p>
<pre><code> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BwmXSixFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span> </span>{
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> CarFrame <span class="title">createCarFrame</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> BwmXSixCarFrame(<span class="string">"中大型SUV"</span>,<span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">4929</span>,<span class="number">1983</span>,<span class="number">1709</span>},<span class="string">"5门5座SUV"</span>);
    }
   <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> Engine <span class="title">createEngine</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> BwmXSixEngine(<span class="string">"3.0T"</span>);
   }
   <span class="annotation">@Override</span>
     <span class="function"><span class="keyword">public</span> Gearbox <span class="title">createGearbox</span><span class="params">()</span> </span>{
       <span class="keyword">return</span> <span class="keyword">new</span> BwmXSixGearbox(<span class="string">"8挡手自一体"</span>);
   }
}
</code></pre><p>程序写到这里也快结束了，我们自己在写一个汽车超市来生成这些对象就好了，希望你有一次愉快的购物经历，哈哈～</p>
<h2 id="总结">总结</h2><p>在抽象工厂模式的运用中，需要有一个总的抽象工厂，这个工厂制造可以生产具体东西的工厂类，比如，CarFactory和BwmXSixFactory之间的关系。然后就是接口的运用。接口对于高抽象层级的类有很大作用，站在高处便能规定对继承该接口的类的行为，但并不具体到每一个继承的类的行为。最后，工厂模式成功的隐藏了类的行为，满足迪米特法则，调用者根本不关心怎么实现的，只要一个接口可以调用便行。</p>
<p>自己在设计模式这一块还比较弱，以后还需多多学习。设计模式每一个都不是太难，重要的是各个击破之后，将他们拿捏在手中能够灵活的运用到实例的工作中。所以，重要的还是自己能力的提升，加油～</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在学习设计模式的路上越走越远…</p>
<p>今天主要记录记录一下学习的工厂模式。</p>
<h2 id="工厂模式简历">工厂模式简历</h2><h3 id="1、由来">1、由来　　　　</h3><p>当我们创建一个对象，而这个对象的创建过程序纷繁复杂，可能导致大量]]>
    </summary>
    
      <category term="java" scheme="http://wfsovereign.github.io/tags/java/"/>
    
      <category term="工厂模式" scheme="http://wfsovereign.github.io/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://wfsovereign.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://wfsovereign.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅析javascript原型与对象]]></title>
    <link href="http://wfsovereign.github.io/2015/02/06/%E6%B5%85%E6%9E%90javascript%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>http://wfsovereign.github.io/2015/02/06/浅析javascript原型与对象/</id>
    <published>2015-02-06T06:24:00.000Z</published>
    <updated>2015-10-26T13:52:01.656Z</updated>
    <content type="html"><![CDATA[<p>在我学习与使用javascript三个月中，我一直对javascript的继承关系以及prototype理解不清，导致很多时候为什么这么用说不出个所以然来。截止到本周为止，通过之前的学习以及自己的再学习，自我感觉算是对这一块有了较为清晰的认识，此文将谈谈我对javascript原型与继承的理解，在此之前，我们首先要知道一些基本的知识。 </p>
<h2 id="知识铺垫">知识铺垫</h2><h3 id="1、数据类型">1、数据类型</h3><p>JavaScript中的数据类型在曾经我也有提到过，它包括未定义值（undefined），空值（null），布尔值（boolean），数字（number），字符串（string）以及对象（object），而对象中又包含特殊对象数组（array），并且函数也是对象。其中，字符串（string），对象（object）等都是由构造函数来实现的。讲到这里又得说说JavaScript中的函数了。</p>
<h3 id="2、函数">2、函数</h3><p>就我所知的语言都是有函数这个概念的，所以就不再细说。在 JavaScript 中函数也是一个对象，那么对象又是通过什么来创建的呢？对象是作为现有示例（即原型）对象的副本而创建的，该名称就来自于这一概念，此原型对象的任何属性和方法都将显示为从原型的构造函数创建的对象的属性和方法。可以说，这些对象从其原型继承了属性和方法。</p>
<p>普通的函数与构造函数在JavaScript中都是通过function来创建，不同的是构造函数需要通过大写来标明。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'my name is '</span> + <span class="keyword">this</span>.name + <span class="string">",I'm "</span> + <span class="keyword">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.say_hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello,I'm"</span> + <span class="keyword">this</span>.sex)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype.is_alive = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wfsovereign = <span class="keyword">new</span> Person(<span class="string">'wfsovereign'</span>, <span class="number">21</span>, <span class="string">"boy"</span>);</span><br><span class="line"></span><br><span class="line">wfsovereign.say();  <span class="comment">//output my name is wfsovereign,I'm 21</span></span><br><span class="line"><span class="built_in">console</span>.log(wfsovereign.is_alive());     <span class="comment">//output true</span></span><br><span class="line"><span class="built_in">console</span>.log(wfsovereign.say_hello(), <span class="string">"----"</span>);    <span class="comment">//output undefined</span></span><br></pre></td></tr></table></figure>
<p>此例中，创建了构造函数Person，接受参数为name，age，拥有静态方法say_hello（），实例方法say（）和is_alive（），使用构造函数创建实例对象wfsovereign，能够调用实例方法，调用静态方法时提示未定义。</p>
<p>在构造函数后通过”.”来添加的方法或属性，称之为静态方法或静态属性，这是实例之后的对象不能访问的。因此，我们通过wfsovereign调用say_hello（）时才会提示undefined。</p>
<p>那么，我们写在构造函数的prototype上的方法is_alive（）为什么实例过后仍然能够被访问呢？这个问题我们先放放，先来看看实例对象与构造函数间的联系，通过控制台，我们输出</p>
<pre><code><span class="tag">console</span><span class="class">.log</span>(<span class="tag">wfsovereign</span><span class="class">.prototype</span>);
<span class="tag">console</span><span class="class">.log</span>(<span class="tag">wfsovereign</span><span class="class">.__proto__</span>);
<span class="tag">console</span><span class="class">.log</span>(<span class="tag">wfsovereign</span><span class="class">.constructor</span>);
</code></pre><p>可以看到</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span>    <span class="comment">//wfsovereign.prototype</span></span><br><span class="line">Person&#123;</span><br><span class="line">    is_alive: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;    <span class="comment">//wfsovereign.__proto__)</span></span><br><span class="line">&#123;</span><br><span class="line">    constructor: <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">        is_alive: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            __proto__: <span class="built_in">Object</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;   <span class="comment">//wfsovereign.constructor</span></span><br><span class="line">                <span class="keyword">this</span>.name = name;</span><br><span class="line">                <span class="keyword">this</span>.age = age;</span><br><span class="line">                <span class="keyword">this</span>.sex = sex;</span><br><span class="line">                <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'my name is '</span> + <span class="keyword">this</span>.name + <span class="string">",I'm "</span> + <span class="keyword">this</span>.age)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，实例对象wfsovereign没有prototype属性，但是有了指向构造函数Person.prototype的<strong>proto</strong>属性以及指向构造函数的constructor属性，而Person这一构造函数也有指向object的<strong>proto</strong>属性，说明Person也是通过object创建的一个实例。这个时候我相信聪明如你就能回答上面提出的问题了—我们写在构造函数的prototype上的方法is_alive（）为什么实例过后仍然能够被访问呢？</p>
<p>由此，我们得出，创建的每一个函数都有prototype属性，这是一个指针，它指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。也就是说prototype是通过调用构造函数而创建的那个对象实例的原型对象，并且只有函数才有prototype属性，实例的对象没有该属性，即这里用Person创建的实例wfsovereign是没有prototype这一属性的。</p>
<p>当使用构造函数（Person）创建一个实例（wfsovereign）的时候，实例内部将包含一个内部指针（<strong>proto</strong>)指向构造函数的prototype，这个连接存在于实例和构造函数的prototype之间，而不是实例与构造函数之间，实例与构造函数之间通过constructor连接。知道了prototype是什么和怎么来的之后，我们再来看JavaScript的原型链就容易多了。</p>
<h2 id="继承与原型链">继承与原型链</h2><h3 id="1、原型链的理解">1、原型链的理解</h3><p>JavaScript 不包含传统的类继承模型，而是使用 prototype 原型模型。在JavaScript中，一共有两种类型的值,原始值和对象值。每个对象都有一个内部属性 prototype ,我们通常称之为原型。原型的值可以是一个对象，也可以是null。如果它的值是一个对象，则这个对象也一定有自己的原型。当从一个对象那里调取属性或方法时，如果该对象自身不存在这样的属性或方法，就会自己去关联的prototype对象那里寻找，如果prototype没有，就会去关联的创造者那里找，直到prototype为undefined为止，Object的prototype就是undefined即所有原型都终止于 Object.prototype，这样就形成了一条线性的链，我们称之为原型链。JavaScript正是通过原型链来调用关联创造者的属性与方法的即继承。</p>
<h3 id="2、使用原型的好处">2、使用原型的好处</h3><p>可以让对象实例共享它所包含的属性和方法。也就是说，不必在构造函数中添加定义对象信息，而是可以直接将这些信息添加到原型中，通过指针引用的方式来调用。使用构造函数的主要问题就是每个方法都要在每个实例中创建一遍。</p>
<p>　　</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在我学习与使用javascript三个月中，我一直对javascript的继承关系以及prototype理解不清，导致很多时候为什么这么用说不出个所以然来。截止到本周为止，通过之前的学习以及自己的再学习，自我感觉算是对这一块有了较为清晰的认识，此文将谈谈我对javascri]]>
    </summary>
    
      <category term="javascript" scheme="http://wfsovereign.github.io/tags/javascript/"/>
    
      <category term="原型" scheme="http://wfsovereign.github.io/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="对象" scheme="http://wfsovereign.github.io/tags/%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="javascript" scheme="http://wfsovereign.github.io/categories/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[阶段随想]]></title>
    <link href="http://wfsovereign.github.io/2015/02/01/%E9%98%B6%E6%AE%B5%E9%9A%8F%E6%83%B3/"/>
    <id>http://wfsovereign.github.io/2015/02/01/阶段随想/</id>
    <published>2015-02-01T05:22:00.000Z</published>
    <updated>2015-10-26T15:24:18.434Z</updated>
    <content type="html"><![CDATA[<p>孵化园三个月的学习时间让我学到了很多，更让我发现了更多感兴趣的东西，促使着我不断向前，不敢止步。三个月朝着一个方向认真学习，足以有些成效，所有，公司对我们进行了一次期中考试，检验我们学习效果的同时，也提醒了我要进行一次自我总结。本篇博客将对此次期中考学到的东西进行整理总结，并对接下来的学习做一些规划。</p>
<h2 id="关于期中考">关于期中考</h2><p>某天突然接到消息说公司会对我们进行一次期中考试，兴奋的同时也带着一些紧张，兴奋着即将有机会去向往的TW观摩观摩，紧张着自己的实力是否能得到认可或者说自己目前的实力是否能让HR满意。伴随着紧张期待的心情拿到homework之后，心态却不自觉的平静下来，开始一心钻研需求了，毕竟English Ability还有些low。</p>
<p>读懂需求之后，我并没有按照面向对象的思路来分列出可以抽取的对象，而是直接按照需求来写测试并实现，即TDD。这一块是我目前比较模糊的，我到底应不应首先对需求的总体进行分析，进而罗列出能够抽离出来的对象、类，还是直接按照需求，一小步一小步的来进行Test Driven Development。</p>
<p>当我把整个homework先写测试再实现以后发现现在的程序没有面向对象而是面向过程，这个时候我便着手重构的第二阶段，对项目结构进行重构。将字符串转化为对象那一块提取到ItemsTransformation类中，将对item进行一系列操作的方法提取到ItemStudio类中，再将把item对象输出为字符的方法提取为BuildReceiptView类中，由此，我便有了三个类，执行顺序也很明了，ItemsTransformation -&gt; ItemsStudio -&gt; BuildReceiptView。</p>
<p>接着，我再修改了数据源的获取方式，使该项目有一个支持文本文件输入的通道（There must be a way to supply the application with the input data via text file）。最后，便是建立了类似main的printInventory，来将购物清单打印出来。</p>
<p>整个流程目前来看还是挺简单清晰的，不过，经公司老师一审查，不由漏洞百出的感觉…</p>
<h3 id="1、讲述方式">1、讲述方式</h3><p>可能由于紧张的缘故，让我讲述我的项目的时候，我陷入了细节坑，花了十分钟左右来讲述各个流程细节的实现，但是效果并不好。在讲述一个项目的时候，应该有高屋建瓴的感觉，从一个较高的层次来对项目进行说明。比如，整个项目的流程，每个模块的输入输出及其功能等等，这样的描述让人易于理解。这种思想，《金字塔原理》中有提及，但是当时就是没用到。由此可见，思维表述的方式我还有待加强。</p>
<h3 id="2、源代码命名方式">2、源代码命名方式</h3><p>我整个项目中使用的都是带下划线的命名方式，经老师说明，在源代码中尽量都使用驼峰命名的方式，测试文件中才使用下划线的命名。此外，类名应为名词，方法名为动词，这些都是最基本的。</p>
<h3 id="3、安全问题">3、安全问题</h3><p>项目中所用到的数据，例如商品基税，应该赋值给变量再由变量去对商品加以赋值，而不应该直接赋值给商品，这样会与普通的数字没有区别，可能会出现安全问题，而且以后也不方便修改。</p>
<h3 id="4、函数职责">4、函数职责</h3><p>函数功能应该单一，这是一直在强调的问题，可是自己还是犯了。经老师一提点，才发现有一个方法确实有些复杂臃肿，而自己看的时候居然没怎么发现。由此，以后对函数功能的检查也应该增强。</p>
<h3 id="5、面向对象">5、面向对象</h3><p>老师说从我的程序来看，面向对象的感觉不强，但是紧张的我当时都忘了请教这个项目如何才能做出面向对象的感觉了。嗯，不过这给以后的修行增加了课题，便是面向对象。</p>
<h2 id="源码的进化">源码的进化</h2><p>关于字符串的转化，之前的代码是这样的</p>
<pre><code>  <span class="function"><span class="keyword">function</span> <span class="title">Transfer_input_to_basic_items</span>(<span class="params">some_items_info</span>)</span>{
   <span class="keyword">this</span>.some_items_info = some_items_info
 }
 Transfer_input_to_basic_items.prototype.get_array_string_of_item_info = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="keyword">this</span>.some_items_info = <span class="keyword">this</span>.some_items_info.split(<span class="string">'\n'</span>);
  };
 Transfer_input_to_basic_items.prototype.get_basic_items = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
     <span class="keyword">this</span>.get_array_string_of_item_info();
   <span class="keyword">var</span> basic_items = [];
   <span class="function"><span class="keyword">function</span> <span class="title">build_item_from_input_string</span>(<span class="params">one_info</span>) </span>{
       <span class="keyword">var</span> item = {};
       <span class="keyword">var</span> one_item_info = one_info.split(<span class="string">" at "</span>, <span class="number">2</span>);
       <span class="keyword">var</span> count_and_name_info = one_item_info[<span class="number">0</span>].split(<span class="string">" "</span>);
       <span class="keyword">var</span> name_info = _.last(count_and_name_info, count_and_name_info.length - <span class="number">1</span>);
       <span class="keyword">var</span> name_from_one_info = _.reduce(name_info, <span class="function"><span class="keyword">function</span> (<span class="params">memo, str</span>) </span>{
           <span class="keyword">return</span> memo + <span class="string">' '</span> + str;
       }, <span class="string">''</span>);
       item.name = name_from_one_info.trim();
       item.count = <span class="built_in">parseInt</span>(count_and_name_info[<span class="number">0</span>]);
       item.price = <span class="built_in">parseFloat</span>(one_item_info[<span class="number">1</span>].trim());
       item.summary = item.count * item.price;
       <span class="keyword">return</span> item
   }
   _(<span class="keyword">this</span>.some_items_info).each(<span class="function"><span class="keyword">function</span> (<span class="params">item_info</span>)</span>{
       basic_items.push(build_item_from_input_string(item_info));
   });
   <span class="keyword">return</span> basic_items
};
</code></pre><p>可以看到，命名方式均以下划线方式命名，参数名字也不好，还有局部函数，这个局部函数是我自己的问题，把一个简单问题复杂化了，也可以说是我对字符串处理能力不足。下面上回来之后重构的，</p>
<pre><code> <span class="function"><span class="keyword">function</span> <span class="title">ItemsTransformation</span>(<span class="params">someItemsInfo</span>) </span>{
   <span class="keyword">this</span>.someItemsInfo = someItemsInfo
 }
ItemsTransformation.prototype._getArrayStringOfItemInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
   <span class="keyword">this</span>.someItemsInfo = <span class="keyword">this</span>.someItemsInfo.split(<span class="string">'\n'</span>);
};

 ItemsTransformation.prototype.getBasicItems = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
  <span class="keyword">this</span>._getArrayStringOfItemInfo();
  <span class="keyword">var</span> basicItems = [];
  _(<span class="keyword">this</span>.someItemsInfo).each(<span class="function"><span class="keyword">function</span> (<span class="params">itemInfo</span>) </span>{
      <span class="keyword">var</span> item = {};
      item.name = itemInfo.slice(itemInfo.indexOf(<span class="string">' '</span>) + <span class="number">1</span>, itemInfo.indexOf(<span class="string">' at '</span>));
      item.count = <span class="built_in">parseInt</span>(itemInfo.slice(<span class="number">0</span>, itemInfo.indexOf(<span class="string">' '</span>)));
        item.price = <span class="built_in">parseFloat</span>(itemInfo.slice(itemInfo.indexOf(<span class="string">' at '</span>) + <span class="number">4</span>, itemInfo.length));
      item.summary = item.count * item.price;
      basicItems.push(item);
  });
  <span class="keyword">return</span> basicItems
};
</code></pre><p>可以看到，函数、变量命名方式全部改为驼峰了，并且优化了算法，去掉了那个看起来怪怪的局部方法。下面再看看之前功能不单一的类，</p>
<pre><code> <span class="function"><span class="keyword">function</span> <span class="title">Items_studio</span>(<span class="params">items</span>) </span>{
    <span class="keyword">this</span>.items = items;
  }

 Items_studio.prototype._add_basic_sales_tax_rate = <span class="function"><span class="keyword">function</span> (<span class="params">one_item</span>) </span>{
    one_item.basic_tax_rate = <span class="number">0.1</span>;
    _(loadAllExemptionBasicItemsCategory).each(<span class="function"><span class="keyword">function</span> (<span class="params">ExemptionBasicItemsCategory</span>) </span>{
        _(ExemptionBasicItemsCategory.name).each(<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>{
            <span class="keyword">if</span> (one_item.name == name) {
               one_item.basic_tax_rate = <span class="number">0</span>
           }
       })
   });
};    

Items_studio.prototype._add_import_duty = <span class="function"><span class="keyword">function</span> (<span class="params">one_item</span>) </span>{
   one_item.import_duty_rate = <span class="number">0</span>;
   <span class="keyword">if</span> (one_item.name.indexOf(<span class="string">'imported '</span>) &gt; -<span class="number">1</span>) {
       one_item.import_duty_rate = <span class="number">0.05</span>
   }
};

Items_studio.prototype._add_after_tax_summary = <span class="function"><span class="keyword">function</span> (<span class="params">one_item</span>) </span>{
   <span class="keyword">var</span> calculator = <span class="keyword">new</span> Calculator;
   <span class="keyword">var</span> taxes = calculator.basic_tax_value(one_item) + calculator.import_duty_value(one_item);
   taxes = <span class="built_in">parseFloat</span>(taxes.toString().substring(<span class="number">0</span>, taxes.toString().indexOf(<span class="string">'.'</span>) + <span class="number">3</span>));
   <span class="keyword">if</span> (<span class="built_in">parseInt</span>(taxes.toString().substring(<span class="number">3</span>, <span class="number">4</span>)) &lt; <span class="number">5</span> &amp;&amp; <span class="built_in">parseInt</span>(taxes.toString().substring(<span class="number">3</span>, <span class="number">4</span>)) != <span class="number">0</span>) {
       taxes = <span class="built_in">parseFloat</span>(taxes.toString().substring(<span class="number">0</span>, <span class="number">3</span>) + <span class="string">'5'</span>);
       one_item.after_tax_summary = taxes + one_item.summary;
   } <span class="keyword">else</span> {
       one_item.after_tax_summary = <span class="built_in">parseFloat</span>((<span class="built_in">Math</span>.round(taxes * <span class="number">10</span>) / <span class="number">10</span> + one_item.summary).toFixed(<span class="number">2</span>));
   }
};

Items_studio.prototype.get_receipt_items = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
   <span class="keyword">var</span> self = <span class="keyword">this</span>;
   _(<span class="keyword">this</span>.items).each(<span class="function"><span class="keyword">function</span> (<span class="params">one_item</span>) </span>{
       self._add_basic_sales_tax_rate(one_item);
       self._add_import_duty(one_item);
       self._add_after_tax_summary(one_item);
   });
   <span class="keyword">return</span> <span class="keyword">this</span>.items
};

 <span class="built_in">module</span>.exports = Items_studio;
</code></pre><p>可以看到_add_after_tax_summar（）这个方法确实是有些臃肿不美观了，因为这个方法做了得到税金以及对税金按照取舍规则进行取舍，下面上回来之后重构的这部分代码，</p>
<pre><code>ItemsStudio.prototype._addAfterTaxSummary = function (item) {
var calculator = <span class="keyword">new</span> Calculator;
var taxes = calculator.getBasicTaxValue(item) + calculator.getImportDutyValue(item);
taxes = parseFloat(taxes.toString().substring(<span class="number">0</span>, taxes.toString().indexOf(<span class="string">'.'</span>) + <span class="number">3</span>));
item.afterTaxSummary = (<span class="keyword">this</span>._getValueFromRule(taxes) + item.summary).toFixed(<span class="number">2</span>);
};

ItemsStudio.prototype._getValueFromRule = function (taxes) {
<span class="keyword">if</span> (parseInt(taxes.toString().substring(<span class="number">3</span>, <span class="number">4</span>)) &lt; <span class="number">5</span> &amp;&amp; parseInt(taxes.toString().substring(<span class="number">3</span>, <span class="number">4</span>)) != <span class="number">0</span>) {
    taxes = parseFloat(taxes.toString().substring(<span class="number">0</span>, <span class="number">3</span>) + <span class="string">'5'</span>);
    <span class="keyword">return</span> taxes
} <span class="keyword">else</span> {
    <span class="keyword">return</span> Math.round(taxes * <span class="number">10</span>) / <span class="number">10</span>
}
};
</code></pre><p>这样看起来不仅干净了许多，而且可读性也得到了大大的增强。</p>
<h2 id="短期规划">短期规划</h2><p>经此一役，发现自己还有很多可提高的部分，</p>
<ol>
<li><p>思维表述方式。准备再啃啃《金字塔原理》，将里面所介绍的方法进行自我练习。</p>
</li>
<li><p>面向对象。面向对象的思想还很浅薄，这也是目前我的一个瓶颈，攻克此瓶颈的方法便是多读书，多读一些关于介绍面向对象思想的书。</p>
</li>
<li><p>提高自我要求。对coding中出现的任何臃肿都应立即着手解决。</p>
</li>
</ol>
<p>总的来说，小菜鸟一枚，但我是有理想有目标的小菜鸟，哈哈哈～</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>孵化园三个月的学习时间让我学到了很多，更让我发现了更多感兴趣的东西，促使着我不断向前，不敢止步。三个月朝着一个方向认真学习，足以有些成效，所有，公司对我们进行了一次期中考试，检验我们学习效果的同时，也提醒了我要进行一次自我总结。本篇博客将对此次期中考学到的东西进行整理总结，]]>
    </summary>
    
      <category term="总结" scheme="http://wfsovereign.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="成长" scheme="http://wfsovereign.github.io/tags/%E6%88%90%E9%95%BF/"/>
    
      <category term="经历" scheme="http://wfsovereign.github.io/categories/%E7%BB%8F%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ignore文件的创建与使用]]></title>
    <link href="http://wfsovereign.github.io/2014/12/26/ignore%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://wfsovereign.github.io/2014/12/26/ignore文件的创建与使用/</id>
    <published>2014-12-26T07:39:00.000Z</published>
    <updated>2015-10-26T13:52:16.639Z</updated>
    <content type="html"><![CDATA[<p>在我们使用github提交本地代码时，有些库文件和日志文件是不必要提交的，那如何处理这个问题呢？这个时候我们就会用到.gitignore文件了。这里我会介绍如何创建.gitignore，以及如何处理已提交的不必要的项目文件。此次工作环境是基于ubuntu14.04。</p>
<h3 id="创建">创建</h3><p>首先,.gitignore文件应该是创建在你的项目的根目录下面的，你可以使用</p>
<blockquote>
<p>vim .gitignore </p>
</blockquote>
<p>或者是</p>
<blockquote>
<p>gedit .gitignore</p>
</blockquote>
<p>例如我的一个.gitignore文件如下:</p>
<pre><code>node_modules 
<span class="built_in">dist</span>
.tmp
bower_components
test
<span class="keyword">public</span>
</code></pre><p>这些文件都是库文件以及自动生成的模块，都是不必要提交的。下面我会讲一个关于已提交不必要文件的处理。</p>
<h3 id="对已提交不必要文件的处理方法">对已提交不必要文件的处理方法</h3><p>有时候当我们明白这个gitignore之后才发现我们已经提交不必要的文件了，而自己又是一个较完美主义者，不愿意让那些文件存在我们库里，该怎么做呢？有什么办法吗？办法肯定是有的。</p>
<p>那么我们现在预设的问题模型是：项目文件里有一个node_modules文件，该文件是存储自动生成的模型的文件，然后我已经把这个文件提交到github库里了，现在我明白了这个道里过后想删掉它并且以后都不再提交它。处理的方法：首先，我们再终端进入项目的根文件下面，创建.gitignore文件，并且添加需要忽略提交的文件，如上面我的一个.gitignore文件，然后输入如下命令</p>
<blockquote>
<p>git rm -r –cached node_modules（要删除的文件名）</p>
</blockquote>
<p>然后再</p>
<blockquote>
<p>git push</p>
</blockquote>
<p>最后我们去我们的github的库里去就会发现刚刚删除的东西已经成功删除啦~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在我们使用github提交本地代码时，有些库文件和日志文件是不必要提交的，那如何处理这个问题呢？这个时候我们就会用到.gitignore文件了。这里我会介绍如何创建.gitignore，以及如何处理已提交的不必要的项目文件。此次工作环境是基于ubuntu14.04。</p>]]>
    </summary>
    
      <category term="git" scheme="http://wfsovereign.github.io/tags/git/"/>
    
      <category term="ignore" scheme="http://wfsovereign.github.io/tags/ignore/"/>
    
      <category term="git" scheme="http://wfsovereign.github.io/categories/git/"/>
    
  </entry>
  
</feed>
